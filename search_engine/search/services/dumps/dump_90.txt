<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Продвинутые типажи - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html" class="active"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Продвинутые-типажи"><a class="header" href="#Продвинутые-типажи">Продвинутые типажи</a></h2>
<p>Мы познакомились с трейтами в разделе <a href="ch10-02-traits.html#traits-defining-shared-behavior">&quot;Трейты: Определение общего поведения&quot;</a><!-- ignore --> в главе 10, но там мы не обсуждали более сложные детали. Теперь, когда вы больше знаете о Rust, мы можем перейти к более подробному рассмотрению.</p>
<h3 id="Указание-типов-заполнителей-в-определениях-трейтов-с-ассоциированными-типами"><a class="header" href="#Указание-типов-заполнителей-в-определениях-трейтов-с-ассоциированными-типами">Указание типов-заполнителей в определениях трейтов с ассоциированными типами</a></h3>
<p><em>Ассоциированные типы</em> связывают тип-заполнитель с типажом таким образом, что определения методов типажа могут использовать эти типы-заполнители в своих сигнатурах. Для конкретной реализации типажа вместо типа-заполнителя указывается конкретный тип, который будет использоваться. Таким образом, мы можем определить типажи, использующие некоторые типы, без необходимости точно знать, что это за типы, пока типажи не будут реализованы.</p>
<p>Мы назвали большинство продвинутых возможностей в этой главе редко востребованными. Ассоциированные типы находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.</p>
<p>Одним из примеров трейта с ассоциированным типом является типаж <code>Iterator</code> из стандартной библиотеки. Ассоциированный тип называется <code>Item</code> и символизирует тип значений, по которым итерируется тип, реализующий типаж <code>Iterator</code>. Определение трейта <code>Iterator</code> показано в листинге 19-12.</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-12/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 19-12: Определение трейта <code>Iterator</code>, который имеет ассоциированный тип <code>Item</code></span></p>
<p>Тип <code>Item</code> является заполнителем и определение метода <code>next</code> показывает, что он будет возвращать значения типа <code>Option&lt;Self::Item&gt;</code>. Разработчики типажа <code>Iterator</code> определят конкретный тип для <code>Item</code>, а метод <code>next</code> вернёт <code>Option</code> содержащий значение этого конкретного типа.</p>
<p>Ассоциированные типы могут показаться концепцией похожей на обобщения, поскольку последние позволяют нам определять функцию, не указывая, какие типы она может обрабатывать. Чтобы изучить разницу между этими двумя концепциями, мы рассмотрим реализацию типажа <code>Iterator</code> для типа с именем <code>Counter</code>, который указывает, что тип <code>Item</code> равен <code>u32</code>:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
</code></pre>
<p>Этот синтаксис весьма напоминает обобщённые типы. Так почему же типаж <code>Iterator</code> не определён обобщённым типом, как показано в листинге 19-13?</p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-13/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 19-13: Гипотетическое определение типажа <code>Iterator</code> используя обобщённые типы</span></p>
<p>Разница в том, что при использовании обобщений, как показано в листинге 19-13, мы должны аннотировать типы в каждой реализации; потому что мы также можем реализовать <code>Iterator&lt;String&gt; for Counter</code> или любого другого типа, мы могли бы иметь несколько реализации <code>Iterator</code> для <code>Counter</code>. Другими словами, когда типаж имеет обобщённый параметр, он может быть реализован для типа несколько раз, каждый раз меняя конкретные типы параметров обобщённого типа. Когда мы используем метод <code>next</code> у <code>Counter</code>, нам пришлось бы предоставить аннотации типа, указывая какую реализацию <code>Iterator</code> мы хотим использовать.</p>
<p>С ассоциированными типами не нужно аннотировать типы, потому что мы не можем реализовать типаж у типа несколько раз. В листинге 19-12 с определением, использующим ассоциированные типы можно выбрать только один тип <code>Item</code>, потому что может быть только одно объявление <code>impl Iterator for Counter</code>. Нам не нужно указывать, что нужен итератор значений типа <code>u32</code> везде, где мы вызываем <code>next</code> у <code>Counter</code>.</p>
<p>Ассоциированные типы также становятся частью контракта типажа: разработчики типажа должны предоставить тип, который заменит ассоциированный заполнитель типа. Связанные типы часто имеют имя, описывающее то, как будет использоваться тип, и хорошей практикой является документирование связанного типа в документации по API.</p>
<h3 id="Параметры-обобщённого-типа-по-умолчанию-и-перегрузка-операторов"><a class="header" href="#Параметры-обобщённого-типа-по-умолчанию-и-перегрузка-операторов">Параметры обобщённого типа по умолчанию и перегрузка операторов</a></h3>
<p>Когда мы используем параметры обобщённого типа, мы можем указать конкретный тип по умолчанию для обобщённого типа. Это устраняет необходимость разработчикам указывать конкретный тип, если работает тип по умолчанию. Тип по умолчанию указывается при объявлении обобщённого типа с помощью синтаксиса  <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Отличным примером, когда этот метод полезен, является <em>перегрузка оператора</em> (operator overloading), когда вы настраиваете поведение оператора (например, <code>+</code> ) для определённых ситуаций.</p>
<p>Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Но можно перегрузить перечисленные операции и соответствующие им типажи из <code>std::ops</code> путём реализации типажей, связанных с этими операторами. Например, в листинге 19-14 мы перегружаем оператор <code>+</code>, чтобы складывать два экземпляра <code>Point</code>. Мы делаем это реализуя типаж <code>Add</code> для структуры <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-14/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-14: Реализация типажа <code>Add</code> для перегрузки оператора <code>+</code> для экземпляров <code>Point</code></span></p>
<p>Метод <code>add</code> складывает значения <code>x</code> двух экземпляров <code>Point</code> и значения <code>y</code> у <code>Point</code> для создания нового экземпляра <code>Point</code>. Типаж <code>Add</code> имеет ассоциированный тип с именем <code>Output</code>, который определяет тип, возвращаемый из метода <code>add</code>.</p>
<p>Обобщённый тип по умолчанию в этом коде находится в типаже <code>Add</code> . Вот его определение:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>Этот код должен выглядеть знакомым: типаж с одним методом и ассоциированным типом. Новый синтаксис это <code>RHS=Self</code>. Такой синтаксис называется <em>параметры типа по умолчанию</em> (default type parameters). Параметр обобщённого типа <code>RHS</code> (сокращённо “right hand side”) определяет тип параметра <code>rhs</code> в методе <code>add</code>. Если мы не укажем конкретный тип для <code>RHS</code> при реализации типажа <code>Add</code>, то типом для <code>RHS</code> по умолчанию будет <code>Self</code>, который будет типом для которого реализуется типаж <code>Add</code>.</p>
<p>Когда мы реализовали <code>Add</code> для структуры <code>Point</code>, мы использовали стандартное значение для <code>RHS</code>, потому что хотели сложить два экземпляра <code>Point</code>. Давайте посмотрим на пример реализации типажа <code>Add</code>, где мы хотим пользовательский тип <code>RHS</code> вместо использования типа по умолчанию.</p>
<p>У нас есть две разные структуры <code>Millimeters</code> и <code>Meters</code>, хранящие значения в разных единицах измерения. Это тонкое обёртывание существующего типа в другую структуру известно как шаблон <em>newtype</em>, который мы более подробно опишем в разделе <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">&quot;Шаблон Newtype для реализация внешних типажей у внешних типов&quot;</a><!-- ignore --> . Мы хотим добавить значения в миллиметрах к значениям в метрах и хотим иметь реализацию типажа <code>Add</code>, которая делает правильное преобразование единиц. Можно реализовать <code>Add</code> для <code>Millimeters</code> с типом <code>Meters</code> в качестве <code>Rhs</code>, как показано в листинге 19-15.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-15/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 19-15: Реализация типажа <code>Add</code> для структуры  <code>Millimeters</code>, чтобы складывать <code>Millimeters</code> и <code>Meters</code></span></p>
<p>Чтобы сложить <code>Millimeters</code> и <code>Meters</code>, мы указываем <code>impl Add&lt;Meters&gt;</code>, чтобы указать значение параметра типа <code>RHS</code> (Meters) вместо использования значения по умолчанию <code>Self</code> (Millimeters).</p>
<p>Параметры типа по умолчанию используются в двух основных случаях:</p>
<ul>
<li>Чтобы расширить тип без внесения изменений ломающих существующий код</li>
<li>Чтобы позволить пользовательское поведение в специальных случаях, которые не нужны большинству пользователей</li>
</ul>
<p>Типаж <code>Add</code> из стандартной библиотеки является примером второй цели: обычно вы складываете два одинаковых типа, но типаж <code>Add</code> позволяет сделать больше. Использование параметра типа по умолчанию в объявлении типажа <code>Add</code> означает, что не нужно указывать дополнительный параметр большую часть времени. Другими словами, большая часть кода реализации не нужна, что делает использование типажа проще.</p>
<p>Первая цель похожа на вторую, но используется наоборот: если вы хотите добавить параметр типа к существующему типажу, можно дать ему значение по умолчанию, чтобы разрешить расширение функциональности типажа без нарушения кода существующей реализации.</p>
<h3 id="Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-методов-с-одинаковым-именем"><a class="header" href="#Полностью-квалифицированный-синтаксис-для-устранения-неоднозначности-вызов-методов-с-одинаковым-именем">Полностью квалифицированный синтаксис для устранения неоднозначности: вызов методов с одинаковым именем</a></h3>
<p>В Rust ничего не мешает типажу иметь метод с одинаковым именем, таким же как метод другого типажа и Rust не мешает реализовывать оба таких типажа у одного типа. Также возможно реализовать метод с таким же именем непосредственно у типа, такой как и методы у типажей.</p>
<p>При вызове методов с одинаковыми именами в Rust нужно указать, какой из трёх возможных вы хотите использовать. Рассмотрим код в листинге 19-16, где мы определили два типажа: <code>Pilot</code> и <code>Wizard</code>, у обоих есть метод <code>fly</code>. Затем мы реализуем оба типажа у типа <code>Human</code> в котором уже реализован метод с именем <code>fly</code>. Каждый метод <code>fly</code> делает что-то своё.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-16/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-16: Два типажа определены с методом <code>fly</code> и реализованы у типа <code>Human</code>, а также метод <code>fly</code> реализован непосредственно у <code>Human</code></span></p>
<p>Когда мы вызываем <code>fly</code> у экземпляра <code>Human</code>, то компилятор по умолчанию вызывает метод, который непосредственно реализован для типа, как показано в листинге 19-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-17/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-17: Вызов <code>fly</code> у экземпляра <code>Human</code></span></p>
<p>Запуск этого кода напечатает <code>*waving arms furiously*</code> , показывая, что Rust называется метод <code>fly</code> реализованный непосредственно у <code>Human</code>.</p>
<p>Чтобы вызвать методы <code>fly</code> у типажа <code>Pilot</code> или типажа <code>Wizard</code> нужно использовать более явный синтаксис, указывая какой метод <code>fly</code> мы имеем в виду. Листинг 19-18 демонстрирует такой синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-18/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-18: Указание какой метода <code>fly</code> мы хотим вызвать</span></p>
<p>Указание имени типажа перед именем метода проясняет компилятору Rust, какую именно реализацию <code>fly</code> мы хотим вызвать. Мы могли бы также написать <code>Human::fly(&amp;person)</code>, что эквивалентно используемому нами <code>person.fly()</code> в листинге 19-18, но это писание немного длиннее, когда нужна неоднозначность.</p>
<p>Выполнение этого кода выводит следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-18/output.txt}}
</code></pre>
<p>Поскольку метод <code>fly</code> принимает параметр <code>self</code>, если у нас было два <em>типа</em> оба реализующих один <em>типаж</em>, то Rust может понять, какую реализацию типажа использовать в зависимости от типа <code>self</code>.</p>
<p>Однако, ассоциированные функции, не являющиеся методами, не имеют параметра <code>self</code>. Когда существует несколько типов или типажей, определяющих функции, не являющиеся методами, с одним и тем же именем функции, Rust не всегда знает, какой тип вы имеете в виду, если только вы не используете <em>полный синтаксис</em>. Например, в листинге 19-19 мы создаём типаж для приюта животных, который хочет назвать всех маленьких собак <em>Spot</em>. Мы создаём типаж <code>Animal</code> со связанной с ним функцией <code>baby_name</code>, не являющейся методом. Типаж <code>Animal</code> реализован для структуры <code>Dog</code>, для которой мы также напрямую предоставляем связанную функцию <code>baby_name</code>, не являющуюся методом.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-19/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-19: Типаж с ассоциированной функцией и тип с ассоциированной функцией с тем же именем, которая тоже реализует типаж</span></p>
<p>Мы реализовали код для приюта для животных, который хочет назвать всех щенков именем Spot, в ассоциированной функции <code>baby_name</code>, которая определена для <code>Dog</code>. Тип <code>Dog</code> также реализует типаж <code>Animal</code>, который описывает характеристики, которые есть у всех животных. Маленьких собак называют щенками, и это выражается в реализации <code>Animal</code> у <code>Dog</code> в функции <code>baby_name</code> ассоциированной с типажом <code>Animal</code>.</p>
<p>В <code>main</code> мы вызываем функцию <code>Dog::baby_name</code>, которая вызывает ассоциированную функцию определённую напрямую у <code>Dog</code>. Этот код печатает следующее:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-19/output.txt}}
</code></pre>
<p>Этот вывод не является тем, что мы хотели бы получить. Мы хотим вызвать функцию <code>baby_name</code>, которая является частью типажа <code>Animal</code> реализованного у <code>Dog</code>, так чтобы код печатал <code>A baby dog is called a puppy</code>. Техника указания имени типажа использованная в листинге 19-18 здесь не помогает; если мы изменим <code>main</code> код как в листинге 19-20, мы получим ошибку компиляции.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-20/src/main.rs:here}}
</code></pre>
<p><span class="caption">Листинг 19-20. Попытка вызвать функцию <code>baby_name</code> из типажа <code>Animal</code>, но Rust не знает какую реализацию использовать</span></p>
<p>Поскольку <code>Animal::baby_name</code> не имеет параметра <code>self</code>, и могут быть другие типы, реализующие типаж <code>Animal</code>, Rust не может понять, какую реализацию <code>Animal::baby_name</code> мы хотим использовать. Мы получим эту ошибку компилятора:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-20/output.txt}}
</code></pre>
<p>Чтобы устранить неоднозначность и сказать Rust, что мы хотим использовать реализацию <code>Animal</code> для <code>Dog</code>, нужно использовать полный синтаксис. Листинг 19-21 демонстрирует, как использовать полный синтаксис.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-21/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-21: Использование полного синтаксиса для указания, что мы мы хотим вызвать функцию <code>baby_name</code> у типажа <code>Animal</code> реализованную в <code>Dog</code></span></p>
<p>Мы указываем аннотацию типа в угловых скобках, которая указывает на то что мы хотим вызвать метод <code>baby_name</code> из типажа <code>Animal</code> реализованный в <code>Dog</code>, также указывая что мы хотим рассматривать тип <code>Dog</code> в качестве <code>Animal</code> для вызова этой функции. Этот код теперь напечатает то, что мы хотим:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-21/output.txt}}
</code></pre>
<p>В общем, полный синтаксис определяется следующим образом:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>Для ассоциированных функций, которые не являются методами, будет отсутствовать <code>receiver</code> (объект приёмника): будет только список аргументов. Вы можете использовать полный синтаксис везде, где вызываете функции или методы. Тем не менее, разрешается опустить любую часть этого синтаксиса, которую Rust может понять из другой информации в программе. Вам нужно использовать более подробный синтаксис только в тех случаях, когда существует несколько реализаций, использующих одно и то же название, и Rust нужно помочь определить, какую реализацию вы хотите вызвать.</p>
<h3 id="Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа"><a class="header" href="#Использование-супер-типажей-для-требования-функциональности-одного-типажа-в-рамках-другого-типажа">Использование супер типажей для требования функциональности одного типажа в рамках другого типажа</a></h3>
<p>Иногда вы можете написать определение типажа, которое зависит от другого типажа: для типа, реализующего первый типаж, вы хотите потребовать, чтобы этот тип также реализовал второй типаж. Вы должны сделать это, чтобы ваше определение типажа могло использовать связанные элементы второго типажа. Типаж, на который опирается ваше определение типажа, называется <em>supertrait</em> вашего типажа.</p>
<p>Например, мы хотим создать типаж <code>OutlinePrint</code> с методом <code>outline_print</code>, который будет печатать значение обрамлённое звёздочками. Мы хотим чтобы структура <code>Point</code>, реализующая типаж стандартной библиотеки <code>Display</code>, вывела на печать <code>(x, y)</code> при вызове <code>outline_print</code> у экземпляра <code>Point</code>, который имеет значение <code>1</code> для <code>x</code> и значение <code>3</code> для <code>y</code>. Она должна напечатать следующее:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>В реализации <code>outline_print</code> мы хотим использовать функциональность типажа <code>Display</code>. Поэтому нам нужно указать, что типаж <code>OutlinePrint</code> будет работать только для типов, которые также реализуют <code>Display</code> и предоставляют функциональность, которая нужна в <code>OutlinePrint</code>. Мы можем сделать это в объявлении типажа, указав <code>OutlinePrint: Display</code>. Этот метод похож на добавление ограничения в типаж. В листинге 19-22 показана реализация типажа <code>OutlinePrint</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-22/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-22: Реализация типажа <code>OutlinePrint</code> которая требует функциональности типажа <code>Display</code></span></p>
<p>Поскольку мы указали, что типаж <code>OutlinePrint</code> требует типажа <code>Display</code>, мы можем использовать функцию <code>to_string</code>, которая автоматически реализована для любого типа реализующего <code>Display</code>. Если бы мы попытались использовать <code>to_string</code> не добавляя двоеточие и не указывая типаж <code>Display</code> после имени типажа, мы получили бы сообщение о том, что метод с именем <code>to_string</code> не был найден у типа <code>&amp;Self</code> в текущей области видимости.</p>
<p>Давайте посмотрим что происходит, если мы пытаемся реализовать типаж <code>OutlinePrint</code> для типа, который не реализует <code>Display</code>, например структура <code>Point</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
</code></pre>
<p>Мы получаем сообщение о том, что требуется реализация <code>Display</code>, но её нет:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
</code></pre>
<p>Чтобы исправить, мы реализуем <code>Display</code> у структуры <code>Point</code> и выполняем требуемое ограничение <code>OutlinePrint</code>, вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Тогда реализация типажа <code>OutlinePrint</code> для структуры <code>Point</code> будет скомпилирована успешно и мы можем вызвать <code>outline_print</code> у экземпляра <code>Point</code> для отображения значения обрамлённое звёздочками.</p>
<h3 id="Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-типов"><a class="header" href="#Шаблон-newtype-для-реализация-внешних-типажей-у-внешних-типов">Шаблон Newtype для реализация внешних типажей у внешних типов</a></h3>
<p>В разделе <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">&quot;Реализация типажа у типа&quot;</a><!-- ignore --> главы 10, мы упоминали &quot;правило сироты&quot; (orphan rule), которое гласит, что разрешается реализовать типаж у типа, если либо типаж, либо тип являются локальными для нашего крейта. Можно обойти это ограничение, используя <em>шаблон нового типа</em> (newtype pattern), который включает в себя создание нового типа в кортежной структуре. (Мы рассмотрели кортежные структуры  в разделе <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">&quot;Использование структур кортежей без именованных полей для создания различных типов&quot;</a><!--  --> главы 5.) Структура кортежа будет иметь одно поле и будет тонкой оболочкой для типа которому мы хотим реализовать типаж. Тогда тип оболочки является локальным для нашего крейта и мы можем реализовать типаж для локальной обёртки. <em>Newtype</em> это термин, который происходит от языка программирования Haskell. В нем нет ухудшения производительности времени выполнения при использовании этого шаблона и тип оболочки исключается во время компиляции.</p>
<p>В качестве примера, мы хотим реализовать типаж <code>Display</code> для типа <code>Vec&lt;T&gt;</code>, где &quot;правило сироты&quot; (orphan rule) не позволяет нам этого делать напрямую, потому что типаж <code>Display</code> и тип <code>Vec&lt;T&gt;</code> объявлены вне нашего крейта. Мы можем сделать структуру <code>Wrapper</code>, которая содержит экземпляр <code>Vec&lt;T&gt;</code>; тогда мы можем реализовать <code>Display</code> у структуры <code>Wrapper</code> и использовать значение <code>Vec&lt;T&gt;</code> как показано в листинге 19-23.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-23/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-23. Создание типа <code>Wrapper</code> <code>Vec&lt;String&gt;</code> для реализации <code>Display</code></span></p>
<p>Реализация <code>Display</code> использует <code>self.0</code> для доступа к внутреннему <code>Vec&lt;T&gt;</code>, потому что <code>Wrapper</code> это структура кортежа, а <code>Vec&lt;T&gt;</code> это элемент с индексом 0 в кортеже. Затем мы можем использовать функциональные возможности типа <code>Display</code> у <code>Wrapper</code>.</p>
<p>Недостатком использования этой техники является то, что <code>Wrapper</code> является новым типом, поэтому он не имеет методов для значения, которое он держит в себе. Мы должны были бы реализовать все методы для <code>Vec&lt;T&gt;</code> непосредственно во <code>Wrapper</code>, так чтобы эти методы делегировались внутреннему <code>self.0</code>, что позволило бы нам обращаться с <code>Wrapper</code> точно так же, как с <code>Vec&lt;T&gt;</code>. Если бы мы хотели, чтобы новый тип имел каждый метод имеющийся у внутреннего типа, реализуя типаж <code>Deref</code> (обсуждается в разделе <a data-md-type="raw_html" href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">&quot;Работа с умными указателями как с обычными ссылками с помощью <code>Deref</code> типажа&quot;</a><!-- ignore --> главы 15) у <code>Wrapper</code> для возвращения внутреннего типа, то это было бы решением. Если мы не хотим, чтобы тип <code>Wrapper</code> имел все методы внутреннего типа, например, для ограничения поведения типа <code>Wrapper</code>, то пришлось бы вручную реализовать только те методы, которые нам нужны.</p>
<p>Этот шаблон newtype также полезен, даже когда типажи не задействованы. Давайте переключим внимание и рассмотрим некоторые продвинутые способы взаимодействия с системой типов Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch19-04-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch19-04-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
