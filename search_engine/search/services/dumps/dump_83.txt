<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Реализация шаблона объектно-ориентированного проектирования - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Реализация-объектно-ориентированного-шаблона-проектирования"><a class="header" href="#Реализация-объектно-ориентированного-шаблона-проектирования">Реализация объектно-ориентированного шаблона проектирования</a></h2>
<p><em>Шаблон &quot;Состояние&quot;</em> — это объектно-ориентированный шаблон проектирования. Суть шаблона заключается в том, что мы определяем набор состояний, которые может иметь внутреннее значение. Состояния представлены набором <em>объектов состояния</em>, а поведение элемента изменяется в зависимости от его состояния. Мы рассмотрим пример структуры записи в блоге, в которой есть поле для хранения состояния, которое будет объектом состояния из набора «черновик», «обзор» или «опубликовано».</p>
<p>Объекты состояния имеют общую функциональность: конечно в Rust мы используем структуры и типажи, а не объекты и наследование. Каждый объект состояния отвечает за своё поведение и сам определяет, когда он должен перейти в другое состояние. Элемент, который содержит объект состояния, ничего не знает о различиях в поведении состояний или о том, когда одно состояние должно перейти в другое.</p>
<p>Преимуществом шаблона &quot;Состояние&quot; является то, что при изменении требований заказчика программы не требуется изменять код элемента, содержащего состояние, или код, использующий такой элемент. Нам нужно только обновить код внутри одного из объектов состояния, чтобы изменить его порядок действий, либо, возможно, добавить больше объектов состояния.</p>
<p>Для начала реализуем шаблон &quot;Состояние&quot; более традиционным объектно-ориентированным способом, а затем воспользуемся подходом, более естественным для Rust. Давайте шаг за шагом реализуем поток действий для записи в блоге, использующий шаблон &quot;Состояние&quot;.</p>
<p>Окончательный функционал будет выглядеть так:</p>
<ol>
<li>Запись в блоге создаётся как пустой черновик.</li>
<li>Когда черновик готов, запрашивается его проверка.</li>
<li>После проверки происходит публикация записи.</li>
<li>Только опубликованные записи блога возвращают содержимое записи на печать, поэтому сообщения, не прошедшие проверку, не могут быть опубликованы случайно.</li>
</ol>
<p>Любые другие изменения, сделанные в записи, не должны иметь никакого эффекта. Например, если мы попытаемся подтвердить черновик записи в блоге до того, как запросим проверку, запись должна остаться неопубликованным черновиком.</p>
<p>В листинге 17-11 показан этот поток действий в виде кода: это пример использования API, который мы собираемся реализовать в библиотеке (крейте) с именем <code>blog</code>. Он пока не компилируется, потому что крейт <code>blog</code> ещё не создан.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:all}}
</code></pre>
<p><span class="caption">Листинг 17-11: Код, демонстрирующий желаемое поведение, которое мы хотим получить в крейте <code>blog</code></span></p>
<p>Мы хотим, чтобы пользователь мог создать новый черновик записи в блоге с помощью <code>Post::new</code>. Затем мы хотим разрешить добавление текста в запись блога. Если мы попытаемся получить содержимое записи сразу, до её проверки, мы не должны получить никакого текста на выходе, потому что запись все ещё является черновиком. Мы добавили утверждение (<code>assert_eq!</code>) в коде для демонстрационных целей. Утверждение (assertion), что черновик записи блога должен возвращать пустую строку из метода <code>content</code> было бы отличным модульным тестом, но мы не собираемся писать тесты для этого примера.</p>
<p>Далее мы хотим разрешить сделать запрос на проверку записи и хотим, чтобы <code>content</code> возвращал пустую строку, пока проверки не завершена. Когда запись пройдёт проверку, она должна быть опубликована, то есть при вызове <code>content</code> будет возвращён текст записи.</p>
<p>Обратите внимание, что единственный тип из крейта, с которым мы взаимодействуем - это тип <code>Post</code>. Этот тип будет использовать шаблон &quot;Состояние&quot; и будет содержать значение, которое будет являться одним из трёх объектов состояний, представляющих различные состояния, в которых может находиться запись: &quot;черновик&quot;, &quot;ожидание проверки&quot; или &quot;опубликовано&quot;. Управление переходом из одного состояния в другое будет осуществляться внутренней логикой типа <code>Post</code>. Состояния будут переключаться в результате реакции на вызов методов экземпляра <code>Post</code> пользователями нашей библиотеки, но пользователи не должны управлять изменениями состояния напрямую. Кроме того, пользователи не должны иметь возможность ошибиться с состояниями, например, опубликовать сообщение до его проверки.</p>
<h3 id="Определение-post-и-создание-нового-экземпляра-в-состоянии-черновика"><a class="header" href="#Определение-post-и-создание-нового-экземпляра-в-состоянии-черновика">Определение <code>Post</code> и создание нового экземпляра в состоянии черновика</a></h3>
<p>Приступим к реализации библиотеки! Мы знаем, что нам нужна публичная структура <code>Post</code>, хранящая некоторое содержимое, поэтому мы начнём с определения структуры и связанной с ней публичной функцией <code>new</code> для создания экземпляра <code>Post</code>, как показано в листинге 17-12. Мы также сделаем приватный типаж <code>State</code>, который будет определять поведение, которое должны будут иметь все объекты состояний структуры <code>Post</code>.</p>
<p>Затем <code>Post</code> будет содержать типаж-объект <code>Box&lt;dyn State&gt;</code> внутри <code>Option&lt;T&gt;</code> в закрытом поле <code>state</code> для хранения объекта состояния. Чуть позже вы поймёте, зачем нужно использовать <code>Option&lt;T&gt;</code> .</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-12/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 17-12. Определение структуры <code>Post</code> и функции <code>new</code>, которая создаёт новый экземпляр <code>Post</code>, типажа <code>State</code> и структуры <code>Draft</code></span></p>
<p>Типаж <code>State</code> определяет поведение, совместно используемое различными состояниями поста. Все объекты состояний (<code>Draft</code> - &quot;черновик&quot;, <code>PendingReview</code>  - &quot;ожидание проверки&quot; и <code>Published</code> - &quot;опубликовано&quot;) будут реализовывать типаж <code>State</code>. Пока у этого типажа нет никаких методов, и мы начнём с определения состояния <code>Draft</code>, просто потому, что это первое состояние, с которого, как мы хотим, публикация будет начинать свой путь.</p>
<p>Когда мы создаём новый экземпляр <code>Post</code>, мы устанавливаем его поле <code>state</code> в значение <code>Some</code>, содержащее <code>Box</code>. Этот <code>Box</code> указывает на новый экземпляр структуры <code>Draft</code>. Это гарантирует, что всякий раз, когда мы создаём новый экземпляр <code>Post</code>, он появляется как черновик. Поскольку поле <code>state</code> в структуре <code>Post</code> является приватным, нет никакого способа создать <code>Post</code> в каком-либо другом состоянии! В функции <code>Post::new</code> мы инициализируем поле <code>content</code> новой пустой строкой типа <code>String</code>.</p>
<h3 id="Хранение-текста-содержимого-записи"><a class="header" href="#Хранение-текста-содержимого-записи">Хранение текста содержимого записи</a></h3>
<p>В листинге 17-11 показано, что мы хотим иметь возможность вызывать метод <code>add_text</code> и передать ему <code>&amp;str</code>, которое добавляется к текстовому содержимому записи блога. Мы реализуем эту возможность как метод, а не делаем поле <code>content</code> публично доступным, используя <code>pub</code>. Это означает, что позже мы сможем написать метод, который будет контролировать, как именно читаются данные из поля <code>content</code>. Метод <code>add_text</code> довольно прост, поэтому давайте добавим его реализацию в блок <code>impl Post</code>листинга 17-13:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-13/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-13. Реализация <code>add_text</code> для добавления текста к <code>content</code> (содержимому записи)</span></p>
<p>Метод <code>add_text</code> принимает изменяемую ссылку на <code>self</code>, потому что мы меняем экземпляр <code>Post</code>, для которого вызываем <code>add_text</code>. Затем мы вызываем <code>push_str</code> для <code>String</code> у поля <code>content</code> и передаём <code>text</code> аргументом для добавления к сохранённому <code>content</code>. Это поведение не зависит от состояния, в котором находится запись, таким образом оно не является частью шаблона &quot;Состояние&quot;. Метод <code>add_text</code> вообще не взаимодействует с полем <code>state</code>, но это часть поведения, которое мы хотим поддерживать.</p>
<h3 id="Убедимся-что-содержание-черновика-будет-пустым"><a class="header" href="#Убедимся-что-содержание-черновика-будет-пустым">Убедимся, что содержание черновика будет пустым</a></h3>
<p>Даже после того, как мы вызвали <code>add_text</code> и добавили некоторый контент в нашу запись, мы хотим, чтобы метод <code>content</code> возвращал пустой фрагмент строки, так как запись всё ещё находится в черновом состоянии, как это показано в строке 7 листинга 17-11. А пока давайте реализуем метод <code>content</code> наиболее простым способом, который будет удовлетворять этому требованию: будем всегда возвращать пустой фрагмент строки. Мы изменим код позже, как только реализуем возможность изменить состояние записи, чтобы она могла бы быть опубликована. Пока что записи могут находиться только в черновом состоянии, поэтому содержимое записи всегда должно быть пустым. Листинг 17-14 показывает такую реализацию-заглушку:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-14/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-14. Добавление реализации-заглушки для метода <code>content</code> в <code>Post</code>, которая всегда возвращает пустой фрагмент строки.</span></p>
<p>С добавленным таким образом методом <code>content</code> всё в листинге 17-11 работает, как задумано, вплоть до строки 7.</p>
<h3 id="Запрос-на-проверку-записи-меняет-её-состояние"><a class="header" href="#Запрос-на-проверку-записи-меняет-её-состояние">Запрос на проверку записи меняет её состояние</a></h3>
<p>Далее нам нужно добавить функциональность для запроса проверки записи, который должен изменить её состояние с <code>Draft</code> на <code>PendingReview</code>. Листинг 17-15 показывает такой код:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-15/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-15. Реализация методов <code>request_review</code> в структуре <code>Post</code> и типаже <code>State</code></span></p>
<p>Мы добавляем в <code>Post</code> публичный метод с именем <code>request_review</code> (&quot;запросить проверку&quot;), который будет принимать изменяемую ссылку на <code>self</code>. Затем мы вызываем внутренний метод <code>request_review</code> для текущего состояния <code>Post</code>, и этот второй метод <code>request_review</code> поглощает текущее состояние и возвращает новое состояние.</p>
<p>Мы добавляем метод <code>request_review</code> в типаж <code>State</code>; все типы, реализующие этот типаж, теперь должны будут реализовать метод <code>request_review</code>. Обратите внимание, что вместо <code>self</code>, <code>&amp;self</code> или <code>&amp;mut self</code> в качестве первого параметра метода у нас указан <code>self: Box&lt;Self&gt;</code>. Этот синтаксис означает, что метод действителен только при его вызове с обёрткой <code>Box</code>, содержащей наш тип. Этот синтаксис становится владельцем <code>Box&lt;Self&gt;</code>, делая старое состояние недействительным, поэтому значение состояния <code>Post</code> может быть преобразовано в новое состояние.</p>
<p>Чтобы поглотить старое состояние, метод <code>request_review</code> должен стать владельцем значения состояния. Это место, где приходит на помощь тип <code>Option</code> поля <code>state</code> записи <code>Post</code>: мы вызываем метод <code>take</code>, чтобы забрать значение <code>Some</code> из поля <code>state</code> и оставить вместо него значение <code>None</code>, потому что Rust не позволяет иметь неинициализированные поля в структурах. Это позволяет перемещать значение <code>state</code> из <code>Post</code>, а не заимствовать его. Затем мы установим новое значение <code>state</code> как результат этой операции.</p>
<p>Нам нужно временно установить <code>state</code> в <code>None</code>, вместо того, чтобы установить его напрямую с помощью кода вроде <code>self.state = self.state.request_review();</code>. Нам нужно завладеть значением поля <code>state</code>. Это даст нам гарантию, что <code>Post</code> не сможет использовать старое значение <code>state</code> после того, как мы преобразовали его в новое состояние.</p>
<p>Метод <code>request_review</code> в <code>Draft</code> должен вернуть новый экземпляр новой структуры <code>PendingReview</code>, обёрнутый в Box. Эта структура будет представлять состояние, в котором запись ожидает проверки. Структура <code>PendingReview</code> также реализует метод <code>request_review</code>, но не выполняет никаких преобразований. Она возвращает сама себя, потому что, когда мы запрашиваем проверку записи, уже находящейся в состоянии <code>PendingReview</code>, она всё так же должна продолжать оставаться в состоянии <code>PendingReview</code>.</p>
<p>Теперь мы начинаем видеть преимущества шаблона &quot;Состояние&quot;: метод <code>request_review</code> для <code>Post</code> одинаков, он не зависит от значения <code>state</code>. Каждое состояние само несёт ответственность за свои действия.</p>
<p>Оставим метод <code>content</code> у <code>Post</code> таким как есть, возвращающим пустой фрагмент строки. Теперь мы можем иметь <code>Post</code> как в состоянии <code>PendingReview</code>, так и в состоянии <code>Draft</code>, но мы хотим получить такое же поведение в состоянии <code>PendingReview</code>. Листинг 17-11 теперь работает до строки 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="Добавление-approve-для-изменения-поведения-content"><a class="header" href="#Добавление-approve-для-изменения-поведения-content">Добавление <code>approve</code> для изменения поведения <code>content</code></a></h3>
<p>Метод <code>approve</code> (&quot;одобрить&quot;) будет аналогичен методу <code>request_review</code>: он будет устанавливать у <code>state</code> значение, которое должна иметь запись при её одобрении, как показано в листинге 17-16:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-16/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-16. Реализация метода <code>approve</code> для типа <code>Post</code> и типажа <code>State</code></span></p>
<p>Мы добавляем метод <code>approve</code> в типаж <code>State</code>, добавляем новую структуру, которая реализует этот типаж <code>State</code> и структуру для состояния <code>Published</code>.</p>
<p>Подобно тому, как работает <code>request_review</code> для <code>PendingReview</code>, если мы вызовем метод <code>approve</code> для <code>Draft</code>, он не будет иметь никакого эффекта, потому что <code>approve</code> вернёт <code>self</code>. Когда мы вызываем для <code>PendingReview</code> метод <code>approve</code>, то он возвращает новый упакованный экземпляр структуры <code>Published</code>. Структура <code>Published</code> реализует трейт <code>State</code>, и как для метода <code>request_review</code>, так и для метода <code>approve</code> она возвращает себя, потому что в этих случаях запись должна оставаться в состоянии <code>Published</code>.</p>
<p>Теперь нам нужно обновить метод <code>content</code> для <code>Post</code>. Мы хотим, чтобы значение, возвращаемое из <code>content</code>, зависело от текущего состояния <code>Post</code>, поэтому мы собираемся перенести часть функциональности <code>Post</code> в метод <code>content</code>, заданный для <code>state</code>, как показано в листинге 17.17:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch17-oop/listing-17-17/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-17: Обновление метода <code>content</code> в структуре <code>Post</code> для делегирования части функциональности методу <code>content</code> структуры <code>State</code></span></p>
<p>Поскольку наша цель состоит в том, чтобы сохранить все эти действия внутри структур, реализующих типаж <code>State</code>, мы вызываем метод <code>content</code> у значения в поле <code>state</code> и передаём экземпляр публикации (то есть <code>self</code> ) в качестве аргумента. Затем мы возвращаем значение, которое нам выдаёт вызов метода <code>content</code> поля <code>state</code>.</p>
<p>Мы вызываем метод <code>as_ref</code> у <code>Option</code>, потому что нам нужна ссылка на значение внутри <code>Option</code>, а не владение значением. Поскольку <code>state</code> является типом <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, то при вызове метода <code>as_ref</code> возвращается <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. Если бы мы не вызывали <code>as_ref</code>, мы бы получили ошибку, потому что мы не можем переместить <code>state</code> из заимствованного параметра <code>&amp;self</code> функции.</p>
<p>Затем мы вызываем метод <code>unwrap</code>. Мы знаем, что этот метод здесь никогда не приведёт к аварийному завершению программы, так все методы <code>Post</code> устроены таким образом, что после их выполнения, в поле <code>state</code> всегда содержится значение <code>Some</code>. Это один из случаев, про которых мы говорили в разделе <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">&quot;Случаи, когда у вас больше информации, чем у компилятора&quot;</a><!--  --> главы 9 - случай, когда мы знаем, что значение <code>None</code> никогда не встретится, даже если компилятор не может этого понять.</p>
<p>Теперь, когда мы вызываем <code>content</code> у типа <code>&amp;Box&lt;dyn State&gt;</code>, в действие вступает принудительное приведение (deref coercion) для <code>&amp;</code> и <code>Box</code>, поэтому в конечном итоге метод <code>content</code> будет вызван для типа, который реализует типаж <code>State</code>. Это означает, что нам нужно добавить метод <code>content</code> в определение типажа <code>State</code>, и именно там мы поместим логику для определения того, какое содержимое возвращать, в зависимости от текущего состояния, как показано в листинге 17-18:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-18/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-18. Добавление метода <code>content</code> в трейт <code>State</code></span></p>
<p>Мы добавляем реализацию по умолчанию метода <code>content</code>, который возвращает пустой фрагмент строки. Это означает, что нам не придётся реализовывать <code>content</code> в структурах <code>Draft</code> и <code>PendingReview</code>.  Структура <code>Published</code> будет переопределять метод <code>content</code> и вернёт значение из <code>post.content</code>.</p>
<p>Обратите внимание, что для этого метода нам нужны аннотации времени жизни, как мы обсуждали в главе 10. Мы берём ссылку на <code>post</code> в качестве аргумента и возвращаем ссылку на часть этого <code>post</code>, поэтому время жизни возвращённой ссылки связано с временем жизни аргумента <code>post</code>.</p>
<p>И вот, мы закончили - теперь всё из листинга 17-11 работает! Мы реализовали шаблон &quot;Состояние&quot;, определяющий правила процесса работы с записью в блоге. Логика, связанная с этими правилами, находится в объектах состояний, а не разбросана по всей структуре <code>Post</code>.</p>
<blockquote>
<h4 id="Почему-не-перечисление"><a class="header" href="#Почему-не-перечисление">Почему не перечисление?</a></h4>
<p>Возможно, вам было интересно, почему мы не использовали <code>enum</code> с различными возможными состояниями записи в качестве вариантов. Это, безусловно, одно из возможных решений. Попробуйте его реализовать и сравните конечные результаты, чтобы выбрать, какой из вариантов вам больше нравится! Одним из недостатков использования перечисления является то, что в каждом месте, где проверяется значение перечисления, потребуется выражение <code>match</code> или что-то подобное для обработки всех возможных вариантов. Возможно в этом случае нам придётся повторять больше кода, чем это было в решении с типаж-объектом.</p>
</blockquote>
<h3 id="Компромиссы-шаблона-Состояние"><a class="header" href="#Компромиссы-шаблона-Состояние">Компромиссы шаблона &quot;Состояние&quot;</a></h3>
<p>Мы показали, что Rust способен реализовать объектно-ориентированный шаблон &quot;Состояние&quot; для инкапсуляции различных типов поведения, которые должна иметь запись в каждом состоянии. Методы в <code>Post</code> ничего не знают о различных видах поведения. При такой организации кода, нам достаточно взглянуть только на один его участок, чтобы узнать отличия в поведении опубликованной публикации: в реализацию типажа <code>State</code> у структуры <code>Published</code>.</p>
<p>Если бы мы захотели создать альтернативную реализацию, не использующую паттерн состояния, мы могли бы вместо этого использовать выражения <code>match</code> в методах <code>Post</code> или даже в <code>main</code>, которые бы проверяли состояние записи и изменяли поведение в этих местах. Это приведёт к тому, что нам придётся в нескольких местах исследовать все следствия того, что пост перешёл в состояние &quot;опубликовано&quot;! И эта нагрузка будет только увеличиваться по мере добавления новых состояний: для каждого из этих выражений <code>match</code> потребуются дополнительные ответвления.</p>
<p>С помощью шаблона &quot;Состояние&quot; методы <code>Post</code> и участки, где мы используем <code>Post</code>, не требуют использования выражений <code>match</code>, а для добавления нового состояния нужно только добавить новую структуру и реализовать методы типажа у одной этой структуры.</p>
<p>Реализацию с использованием шаблона &quot;Состояние&quot; легко расширить для добавления новой функциональности. Чтобы увидеть, как легко поддерживать код, использующий данный шаблон, попробуйте выполнить некоторые из предложений ниже:</p>
<ul>
<li>Добавьте метод <code>reject</code>, который изменяет состояние публикации с <code>PendingReview</code> обратно на <code>Draft</code>.</li>
<li>Потребуйте два вызова метода <code>approve</code>, прежде чем переводить состояние в <code>Published</code>.</li>
<li>Разрешите пользователям добавлять текстовое содержимое только тогда, когда публикация находится в состоянии <code>Draft</code>. Подсказка: пусть объект состояния решает, можно ли менять содержимое, но не отвечает за изменение <code>Post</code>.</li>
</ul>
<p>Одним из недостатков шаблона &quot;Состояние&quot; является то, что поскольку состояния сами реализуют переходы между собой, некоторые из состояний получаются связанными друг с другом. Если мы добавим другое состояние между <code>PendingReview</code> и <code>Published</code>,  например <code>Scheduled</code> (&quot;запланировано&quot;), то придётся изменить код в <code>PendingReview</code>, чтобы оно теперь переходило в <code>Scheduled</code>. Если бы не нужно было менять <code>PendingReview</code> при добавлении нового состояния, было бы меньше работы, но это означало бы, что мы переходим на другой шаблон проектирования.</p>
<p>Другим недостатком является то, что мы продублировали некоторую логику. Чтобы устранить некоторое дублирование, мы могли бы попытаться сделать реализации по умолчанию для методов <code>request_review</code> и <code>approve</code> типажа <code>State</code>, которые возвращают <code>self</code>; однако это нарушило бы безопасность объекта, потому что типаж не знает, каким конкретно будет <code>self</code>. Мы хотим иметь возможность использовать <code>State</code> в качестве типаж-объекта, поэтому нам нужно, чтобы его методы были объектно-безопасными.</p>
<p>Другое дублирование включает в себя схожие реализации методов <code>request_review</code> и <code>approve</code> у  <code>Post</code>. Оба метода делегируют реализации одного и того же метода значению поля <code>state</code> типа <code>Option</code> и устанавливают результатом новое значение поля <code>state</code>. Если бы у <code>Post</code> было много методов, которые следовали этому шаблону, мы могли бы рассмотреть определение макроса для устранения повторения (смотри раздел <a href="ch19-06-macros.html#macros">&quot;Макросы&quot;</a><!--  --> в главе 19).</p>
<p>Реализуя шаблон &quot;Состояние&quot; точно так, как он определён для объектно-ориентированных языков, мы не настолько полно используем преимущества Rust, как могли бы. Давайте посмотрим на некоторые изменения, которые мы можем внести в крейт <code>blog</code>, чтобы недопустимые состояния и переходы превратить в ошибки времени компиляции.</p>
<h4 id="Кодирование-состояний-и-поведения-в-виде-типов"><a class="header" href="#Кодирование-состояний-и-поведения-в-виде-типов">Кодирование состояний и поведения в виде типов</a></h4>
<p>Мы покажем вам, как переосмыслить шаблон &quot;Состояние&quot;, чтобы получить другой набор компромиссов. Вместо того, чтобы полностью инкапсулировать состояния и переходы, так, чтобы внешний код не знал о них, мы будем кодировать состояния с помощью разных типов. Следовательно, система проверки типов Rust предотвратит попытки использовать черновые публикации, там где разрешены только опубликованные публикации, вызывая ошибки компиляции.</p>
<p>Давайте рассмотрим первую часть <code>main</code> в листинге 17-11:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-11/src/main.rs:here}}
</code></pre>
<p>Мы по-прежнему поддерживаем создание новых сообщений в состоянии &quot;черновика&quot; с помощью метода <code>Post::new</code> и возможность добавлять текст к содержимому публикации. Но вместо метода <code>content</code> у чернового сообщения, возвращающего пустую строку, мы сделаем так, что у черновых сообщений вообще не будет метода <code>content</code>. Таким образом, если мы попытаемся получить содержимое черновика, мы получим ошибку компилятора, сообщающую, что метод не существует. В результате мы не сможем случайно отобразить черновик содержимого записи в работающей программе, потому что этот код даже не скомпилируется. В листинге 17-19 показано определение структур <code>Post</code> и <code>DraftPost</code>, а также методов для каждой из них:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-19/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 17-19: Структура <code>Post</code> с методом <code>content</code> и структура <code>DraftPost</code> без метода <code>content</code></span></p>
<p>Обе структуры, <code>Post</code> и <code>DraftPost</code>, имеют приватное поле <code>content</code>, в котором хранится текст сообщения блога. Структуры больше не содержат поле <code>state</code>, потому что мы перемещаем кодирование состояния в типы структур. Структура <code>Post</code> будет представлять опубликованную публикацию, и у неё есть метод <code>content</code>, который возвращает <code>content</code>.</p>
<p>У нас все ещё есть функция <code>Post::new</code>, но вместо возврата экземпляра <code>Post</code> она возвращает экземпляр <code>DraftPost</code>. Поскольку поле <code>content</code> является приватным и нет никаких функций, которые возвращают <code>Post</code>, просто так создать экземпляр <code>Post</code> уже невозможно.</p>
<p>Структура <code>DraftPost</code> имеет метод <code>add_text</code>, поэтому мы можем добавлять текст к <code>content</code> как и раньше, но учтите, что в <code>DraftPost</code> не определён метод <code>content</code>! Так что теперь программа гарантирует, что все записи начинаются как черновики, а черновики публикаций не имеют своего контента для отображения. Любая попытка обойти эти ограничения приведёт к ошибке компилятора.</p>
<h4 id="Реализация-переходов-в-виде-преобразований-в-другие-типы"><a class="header" href="#Реализация-переходов-в-виде-преобразований-в-другие-типы">Реализация переходов в виде преобразований в другие типы</a></h4>
<p>Так как же получить опубликованный пост? Мы хотим обеспечить соблюдение правила, согласно которому черновик записи должен быть рассмотрен и утверждён до того, как он будет опубликован. Запись, находящаяся в состоянии проверки, по-прежнему не должна отображать содержимое. Давайте реализуем эти ограничения, добавив ещё одну структуру, <code>PendingReviewPost</code>, определив метод <code>request_review</code> у <code>DraftPost</code>, возвращающий <code>PendingReviewPost</code>, и определив метод <code>approve</code> у <code>PendingReviewPost</code>, возвращающий <code>Post</code>, как показано в листинге 17-20:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch17-oop/listing-17-20/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 17-20: Тип <code>PendingReviewPost</code>, который создаётся путём вызова <code>request_review</code> экземпляра <code>DraftPost</code> и метод <code>approve</code>, который превращает <code>PendingReviewPost</code> в опубликованный <code>Post</code>.</span></p>
<p>Методы <code>request_review</code> и <code>approve</code> забирают во владение <code>self</code>, таким образом поглощая экземпляры <code>DraftPost</code> и <code>PendingReviewPost</code>, которые потом преобразуются в <code>PendingReviewPost</code> и опубликованную <code>Post</code>, соответственно. Таким образом, у нас не будет никаких долгоживущих экземпляров <code>DraftPost</code>, после того, как мы вызвали у них <code>request_review</code> и так далее. В структуре <code>PendingReviewPost</code> не определён метод <code>content</code>, поэтому попытка прочитать его содержимое приводит к ошибке компилятора, также как и в случае с <code>DraftPost</code>. Так как единственным способом получить опубликованный экземпляр <code>Post</code>, у которого действительно есть объявленный метод <code>content</code>, является вызов метода <code>approve</code> у экземпляра <code>PendingReviewPost</code>, а единственный способ получить <code>PendingReviewPost</code> - это вызвать метод <code>request_review</code> у экземпляра <code>DraftPost</code>, теперь мы закодировали процесс смены состояний записи блога с помощью системы типов.</p>
<p>Кроме этого, нужно внести небольшие изменения в <code>main</code>. Так как методы <code>request_review</code> и <code>approve</code> теперь возвращают объекты, а не преобразуют структуру от которой были вызваны, нам нужно добавить больше затеняющих присваиваний <code>let post =</code>, чтобы сохранять возвращаемые объекты. Также, теперь мы не можем использовать утверждения (assertions) для проверки того является ли содержимое черновиков и записей, находящихся на рассмотрении, пустыми строками, да они нам и не нужны - теперь стало невозможным скомпилировать код, который бы пытался использовать содержимое записей, находящихся в этих состояниях. Обновлённый код в <code>main</code> показан в листинге 17-21:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch17-oop/listing-17-21/src/main.rs}}
</code></pre>
<p><span class="caption">Листинг 17-21: Изменения в <code>main</code>, использующие новую реализацию процесса подготовки записи блога</span></p>
<p>Изменения, которые нам нужно было внести в <code>main</code>, чтобы переназначить <code>post</code> означают, что эта реализация теперь не совсем соответствует объектно-ориентированному шаблону &quot;Состояние&quot;: преобразования между состояниями больше не инкапсулированы внутри реализации <code>Post</code> полностью. Тем не менее, мы получили большую выгоду в том, что недопустимые состояния теперь невозможны из-за системы типов и проверки типов, которая происходит во время компиляции! У нас есть гарантия, что некоторые ошибки, такие как отображение содержимого неопубликованной публикации, будут обнаружены до того, как они дойдут до пользователей.</p>
<p>Попробуйте выполнить задачи, предложенные в начале этого раздела, в версии крейта <code>blog</code>, каким он стал после листинга 17-20, чтобы сформировать своё мнение о дизайне этой версии кода. Обратите внимание, что некоторые задачи в этом варианте могут быть уже выполнены.</p>
<p>Мы увидели, что хотя Rust и способен реализовывать объектно-ориентированные шаблоны проектирования, в нём также доступны и другие шаблоны, такие как кодирование состояния с помощью системы типов. Эти модели имеют различные компромиссы. Хотя вы, возможно, очень хорошо знакомы с объектно-ориентированными шаблонами, переосмысление проблем для использования преимуществ и возможностей Rust может дать такие выгоды, как предотвращение некоторых ошибок во время компиляции. Объектно-ориентированные шаблоны не всегда будут лучшим решением в Rust из-за наличия определённых возможностей, таких как владение, которого нет у объектно-ориентированных языков.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Независимо от того, что вы думаете о принадлежности Rust к объектно-ориентированным языкам после прочтения этой главы, теперь вы знаете, что можете использовать типаж-объекты, чтобы реализовать некоторые объектно-ориентированные свойства в Rust. Динамическая диспетчеризация может дать вашему коду некоторую гибкость в обмен на небольшое ухудшение производительности во время выполнения. Вы можете использовать эту гибкость для реализации объектно-ориентированных шаблонов, которые могут улучшить сопровождаемость вашего кода. В Rust также есть другие особенности, такие как владение, которых нет у объектно-ориентированных языков. Объектно-ориентированный шаблон не всегда будет лучшим способом использовать преимущества Rust, но является доступной опцией.</p>
<p>Далее мы рассмотрим шаблоны, которые являются ещё одной особенностью Rust, обеспечивающей высокую гибкость. Мы бегло рассказывали о них на протяжении всей книги, но ещё не видели всех их возможностей. Вперёд!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch18-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch18-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
