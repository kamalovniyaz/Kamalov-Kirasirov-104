<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Синтаксис шаблона - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html" class="active"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Синтаксис-шаблонов"><a class="header" href="#Синтаксис-шаблонов">Синтаксис шаблонов</a></h2>
<p>В этом разделе мы рассмотрим все виды допустимого синтаксиса в шаблонах и расскажем, когда и для чего вам может понадобиться каждый из них.</p>
<h3 id="Сопоставление-с-литералом"><a class="header" href="#Сопоставление-с-литералом">Сопоставление с литералом</a></h3>
<p>Как мы уже видели в главе 6, можно сопоставлять шаблоны с литералами напрямую. В следующем коде есть несколько примеров:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-01-literals/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Этот код печатает <code>one</code>, потому что значение в <code>x</code> равно 1. Данный синтаксис полезен, когда вы хотите, чтобы ваш код предпринял действие, если он получает конкретное значение.</p>
<h3 id="Сопоставление-именованных-переменных"><a class="header" href="#Сопоставление-именованных-переменных">Сопоставление именованных переменных</a></h3>
<p>Именованные переменные - это неопровержимые (irrefutable) шаблоны, которые соответствуют любому значению и мы использовали их много раз в книге. Однако при использовании именованных переменных в выражениях <code>match</code> возникает сложность. Поскольку <code>match</code> начинает новую область видимости, то переменные, объявленные как часть шаблона внутри выражения <code>match</code>, будут затенять переменные с тем же именем вне конструкции <code>match</code> как и в случае со всеми переменными. В листинге 18-11 мы объявляем переменную с именем <code>x</code> со значением <code>Some(5)</code> и переменную <code>y</code> со значением <code>10</code>. Затем мы создаём выражение <code>match</code> для значения <code>x</code>. Посмотрите на шаблоны в ветках, <code>println!</code> в конце и попытайтесь выяснить, какой код будет напечатан прежде чем запускать его или читать дальше.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-11/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-11: Выражение <code>match</code> с веткой, которая добавляет затенённую переменную <code>y</code></span></p>
<p>Давайте рассмотрим, что происходит, когда выполняется выражение <code>match</code>. Шаблон в первой ветке не соответствует определённому значению <code>x</code>, поэтому выполнение продолжается.</p>
<p>Шаблон во второй ветке вводит новую переменную с именем <code>y</code>, которая будет соответствовать любому значению в <code>Some</code>. Поскольку мы находимся в новой области видимости внутри выражения <code>match</code>, это новая переменная <code>y</code>, а не <code>y</code> которую мы объявили в начале со значением 10. Эта новая привязка <code>y</code> будет соответствовать любому значению из <code>Some</code>, которое находится в <code>x</code>. Следовательно, эта новая <code>y</code> связывается с внутренним значением <code>Some</code> из переменной <code>x</code>. Этим значением является <code>5</code>, поэтому выражение для этой ветки выполняется и печатает <code>Matched, y = 5</code>.</p>
<p>Если бы <code>x</code> было значением <code>None</code> вместо <code>Some(5)</code>, то шаблоны в первых двух ветках не совпали бы, поэтому значение соответствовало бы подчёркиванию. Мы не ввели переменную <code>x</code> в шаблоне ветки со знаком подчёркивания, поэтому <code>x</code> в выражении все ещё является внешней переменной <code>x</code>, которая не была затенена. В этом гипотетическом случае совпадение <code>match</code> выведет <code>Default case, x = None</code>.</p>
<p>Когда выражение <code>match</code> завершается, заканчивается его область видимости как и область действия внутренней переменной <code>y</code>. Последний <code>println!</code> печатает <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Чтобы создать выражение <code>match</code>, которое сравнивает значения внешних <code>x</code> и <code>y</code>, вместо введения затенённой переменной нужно использовать условие в сопоставлении образца. Мы поговорим про условие в сопоставлении шаблона позже в разделе <a href="#extra-conditionals-with-match-guards">“Дополнительные условия в сопоставлении образца”</a><!--  -->.</p>
<h3 id="Группа-шаблонов"><a class="header" href="#Группа-шаблонов">Группа шаблонов</a></h3>
<p>В выражениях <code>match</code> можно сравнивать сразу с несколькими шаблонами, используя синтаксис <code>|</code>, который является оператором паттерна <em>or</em>. Например, в следующем примере мы сопоставляем значение <code>x</code> с ветвями match, первая из которых содержит оператор <em>or</em>, так что если значение <code>x</code> совпадёт с любым из значений в этой ветви, то будет выполнен её код:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-02-multiple-patterns/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Будет напечатано <code>one or two</code>.</p>
<h3 id="Сопоставление-диапазонов-с-помощью-"><a class="header" href="#Сопоставление-диапазонов-с-помощью-">Сопоставление диапазонов с помощью <code>..=</code></a></h3>
<p>Синтаксис <code>..=</code> позволяет нам выполнять сравнение с диапазоном значений. В следующем коде, когда в шаблоне найдётся совпадение с любым из значений заданного диапазона, будет выполнена эта ветка:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-03-ranges/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Если <code>x</code> равен 1, 2, 3, 4 или 5, то совпадение будет достигнуто в первой ветке. Этот синтаксис более удобен при указании нескольких значений для сравнения, чем использование оператора <code>|</code> для определения этой же идеи; если бы мы решили использовать <code>|</code>, нам пришлось бы написать <code>1 | 2 | 3 | 4 | 5</code>. Указание диапазона намного короче, особенно если мы хотим подобрать, скажем, любое число от 1 до 1 000!</p>
<p>Компилятор проверяет, что диапазон не является пустым во время компиляции, и поскольку единственными типами, для которых Rust может определить, пуст диапазон или нет, являются <code>char</code> и числовые значения, диапазоны допускаются только с числовыми или <code>char</code> значениями.</p>
<p>Вот пример использования диапазонов значений <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-04-ranges-of-char/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Rust может сообщить, что <code>'c'</code> находится в диапазоне первого шаблона и напечатать <code>early ASCII letter</code>.</p>
<h3 id="Деструктуризация-для-получения-значений"><a class="header" href="#Деструктуризация-для-получения-значений">Деструктуризация для получения значений</a></h3>
<p>Мы также можем использовать шаблоны для деструктуризации структур, перечислений и кортежей, чтобы использовать разные части этих значений. Давайте пройдёмся по каждому варианту.</p>
<h4 id="Деструктуризация-структуры"><a class="header" href="#Деструктуризация-структуры">Деструктуризация структуры</a></h4>
<p>В листинге 18-12 показана структура <code>Point</code> с двумя полями <code>x</code> и <code>y</code>, которые мы можем разделить, используя шаблон с инструкцией <code>let</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-12/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-12: Разбиение полей структуры в отдельные переменные</span></p>
<p>Этот код создаёт переменные <code>a</code> и <code>b</code> , которые сопоставляются значениям полей <code>x</code> и <code>y</code> структуры <code>p</code> . Этот пример показывает, что имена переменных в шаблоне не обязательно должны совпадать с именами полей структуры. Однако обычно имена переменных сопоставляются с именами полей, чтобы было легче запомнить, какие переменные взяты из каких полей. Из-за этого, а также из-за того, что строчка <code>let Point { x: x, y: y } = p;</code> содержит много дублирования, в Rust ввели специальное сокращение для шаблонов, соответствующих полям структуры: вам нужно только указать имя поля структуры, и тогда переменные, созданные из шаблона, будут иметь те же имена. Код в листинге 18-13 аналогичен коду в Листинге 18-12, но в шаблоне <code>let</code> создаются переменные <code>x</code> и <code>y</code>, вместо <code>a</code> и <code>b</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-13/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-13: Деструктуризация полей структуры с использованием сокращённой записи</span></p>
<p>Этот код создаёт переменные <code>x</code> и <code>y</code>, которые соответствуют полям <code>x</code> и <code>y</code> из переменной <code>p</code>. В результате переменные <code>x</code> и <code>y</code> содержат значения из структуры <code>p</code>.</p>
<p>А ещё, используя литеральные значения в шаблоне, мы можем деструктурировать, не создавая переменные для всех полей. Это даёт возможность, проверяя одни поля на соответствие конкретным значениям, создавать переменные для деструктуризации других.</p>
<p>В листинге 18-14 показано выражение <code>match</code>, которое разделяет значения <code>Point</code> на три случая: точки, которые лежат непосредственно на оси <code>x</code> (что верно, когда <code>y = 0</code>), на оси <code>y</code> (<code>x = 0</code>) или ни то, ни другое.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-14/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-14: Деструктуризация и сопоставление с литералами в одном шаблоне</span></p>
<p>Первая ветвь будет соответствовать любой точке, лежащей на оси <code>x</code>, если значение поля <code>y</code> будет соответствовать литералу <code>0</code>. Шаблон по-прежнему создаёт переменную <code>x</code>, которую мы сможем использовать в коде этой ветви.</p>
<p>Аналогично, вторая ветвь совпадёт с любой точкой на оси <code>y</code>, в случае, если значение поля <code>x</code> будет равно <code>0</code>, а для значения поля <code>y</code> будет создана переменная <code>y</code>. Третья ветвь не содержит никаких литералов, поэтому она соответствует любому другому <code>Point</code> и создаёт переменные как для поля <code>x</code>, так и для поля <code>y</code>.</p>
<p>В этом примере значение <code>p</code> совпадает по второй ветке, так как <code>x</code> содержит значение 0, поэтому этот код будет печатать <code>On the y axis at 7</code>.</p>
<p>Помните, что выражение <code>match</code> перестаёт проверять следующие ветви, как только оно находит первый совпадающий шаблон, поэтому, даже если <code>Point { x: 0, y: 0}</code> находится на оси <code>x</code> и оси <code>y</code>, этот код будет печатать только <code>On the x axis at 0</code> .</p>
<h4 id="Деструктуризация-перечислений"><a class="header" href="#Деструктуризация-перечислений">Деструктуризация перечислений</a></h4>
<p>Мы уже деструктурировали перечисления в книге (см., например, листинг 6-5 главы 6), но<br>не обсуждали явно, что шаблон для деструктуризации перечисления должен соответствовать способу объявления данных, хранящихся в перечислении. Например, в листинге 18-15 мы используем перечисление <code>Message</code> из листинга 6-2 и пишем <code>match</code> с шаблонами, которые будут деструктурировать каждое внутреннее значение.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-15/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-15: Деструктуризация вариантов перечисления, содержащих разные виды значений</span></p>
<p>Этот код напечатает <code>Change the color to red 0, green 160, and blue 255</code>. Попробуйте изменить значение переменной <code>msg</code>, чтобы увидеть выполнение кода в других ветках.</p>
<p>Для вариантов перечисления без каких-либо данных, вроде <code>Message::Quit</code>, мы не можем деструктурировать значение, которого нет. Мы можем сопоставить только буквальное значение <code>Message::Quit</code> в этом шаблоне, но без переменных.</p>
<p>Для вариантов перечисления похожих на структуры, таких как <code>Message::Move</code>, можно использовать шаблон, подобный шаблону, который мы указываем для сопоставления структур. После имени варианта мы помещаем фигурные скобки и затем перечисляем поля именами переменных. Таким образом мы разделяем фрагменты, которые будут использоваться в коде этой ветки. Здесь мы используем сокращённую форму, как в листинге 18-13.</p>
<p>Для вариантов перечисления, подобных кортежу, вроде <code>Message::Write</code>, который содержит кортеж с одним элементом и <code>Message::ChangeColor</code>, содержащему кортеж с тремя элементами, шаблон аналогичен тому, который мы указываем для сопоставления кортежей. Количество переменных в шаблоне должно соответствовать количеству элементов в варианте, который мы сопоставляем.</p>
<h4 id="Деструктуризация-вложенных-структур-и-перечислений"><a class="header" href="#Деструктуризация-вложенных-структур-и-перечислений">Деструктуризация вложенных структур и перечислений</a></h4>
<p>До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами! Например, мы можем реорганизовать код в листинге 18-15 для поддержки цветов RGB и HSV в сообщении <code>ChangeColor</code> , как показано в листинге 18-16.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-16/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-16: Сопоставление со вложенными перечислениями</span></p>
<p>Шаблон первой ветки в выражении <code>match</code> соответствует варианту перечисления <code>Message::ChangeColor</code>, который содержит вариант <code>Color::Rgb</code>; затем шаблон привязывается к трём внутренними значениями <code>i32</code>. Шаблон второй ветки также соответствует варианту перечисления <code>Message::ChangeColor</code>, но внутреннее перечисление соответствует варианту <code>Color::Hsv</code>. Мы можем указать эти сложные условия в одном выражении <code>match</code>, даже если задействованы два перечисления.</p>
<h4 id="Деструктуризация-структур-и-кортежей"><a class="header" href="#Деструктуризация-структур-и-кортежей">Деструктуризация структур и кортежей</a></h4>
<p>Можно смешивать, сопоставлять и вкладывать шаблоны деструктуризации ещё более сложными способами. В следующем примере показана сложная деструктуризация, где мы вкладываем структуры и кортежи внутрь кортежа и деструктурируем из него все примитивные значения:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/no-listing-05-destructuring-structs-and-tuples/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Этот код позволяет нам разбивать сложные типы на составные части, чтобы мы могли использовать интересующие нас значения по отдельности.</p>
<p>Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений, таких как как значение из каждого поля в структуре, по отдельности друг от друга.</p>
<h3 id="Игнорирование-значений-в-шаблоне"><a class="header" href="#Игнорирование-значений-в-шаблоне">Игнорирование значений в шаблоне</a></h3>
<p>Вы видели, что иногда полезно игнорировать значения в шаблоне, например в последней ветке <code>match</code>, чтобы получить ветку, обрабатывающую любые значения, которая на самом деле ничего не делает, но учитывает все оставшиеся возможные значения. Есть несколько способов игнорировать целые значения или части значений в шаблоне: используя шаблон <code>_</code> (который вы видели), используя шаблон <code>_</code> внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя <code>..</code>, чтобы игнорировать оставшиеся части значения. Давайте рассмотрим, как и зачем использовать каждый из этих шаблонов.</p>
<h4 id="Игнорирование-всего-значения-с-помощью-шаблона-_"><a class="header" href="#Игнорирование-всего-значения-с-помощью-шаблона-_">Игнорирование всего значения с помощью шаблона <code>_</code></a></h4>
<p>Мы использовали подчёркивание (<code>_</code>) в качестве шаблона подстановочного знака (wildcard), который будет сопоставляться с любом значением, но не будет привязываться к этому значению. Это особенно удобно в последней ветке выражения <code>match</code>, но мы также можем использовать его в любом шаблоне, в том числе в параметрах функции, как показано в листинге 18-17.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-17/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-15: Использование <code>_</code> в сигнатуре функции</span></p>
<p>Этот код полностью игнорирует значение <code>3</code>, переданное в качестве первого аргумента, и выведет на печать <code>This code only uses the y parameter: 4</code>.</p>
<p>В большинстве случаев, когда вам больше не нужен какой-то из параметров функции, вы можете изменить её сигнатуру, убрав неиспользуемый параметр. Игнорирование параметра функции может быть особенно полезно в случаях когда, например, вы реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в одном из параметров. В таком случае компилятор не будет выдавать предупреждения о неиспользуемых параметрах функции, как это было бы, если бы вы указали имя параметра.</p>
<h4 id="Игнорирование-частей-значения-с-помощью-вложенного-_"><a class="header" href="#Игнорирование-частей-значения-с-помощью-вложенного-_">Игнорирование частей значения с помощью вложенного <code>_</code></a></h4>
<p>Также, <code>_</code> можно использовать внутри шаблонов, чтобы игнорировать какую-то часть значения, например, когда мы хотим проверить только определённую деталь, а остальные параметры нам не понадобятся в коде, который нужно выполнить. В листинге 18-18 показан код, ответственный за управление значениями настроек. Согласно бизнес-требованиям, пользователь не может изменить установленное значение параметра, но может удалить его и задать ему новое значение, если на данный момент оно отсутствует.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-18/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-18: Использование подчёркивания в шаблонах, соответствующих вариантам <code>Some</code>, когда нам не нужно использовать значение внутри <code>Some</code></span></p>
<p>Этот код будет печатать <code>Can't overwrite an existing customized value</code>, а затем <code>setting is Some(5)</code>. В первой ветке нам не нужно сопоставлять или использовать значения внутри варианта <code>Some</code>, но нам нужно проверить случай, когда <code>setting_value</code> и <code>new_setting_value</code> являются вариантом <code>Some</code>. В этом случае мы печатаем причину, почему мы не меняем значение <code>setting_value</code> и оно не меняется.</p>
<p>Во всех других случаях (если либо <code>setting_value</code>, либо <code>new_setting_value</code> являются вариантом <code>None</code>), выраженных шаблоном <code>_</code> во второй ветке, мы хотим, чтобы <code>new_setting_value</code> стало равно <code>setting_value</code>.</p>
<p>Мы также можем использовать подчёркивание в нескольких местах в одном шаблоне, чтобы игнорировать конкретные значения. Листинг 18-19 показывает пример игнорирования второго и четвёртого значения в кортеже из пяти элементов.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-19/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-19: Игнорирование нескольких частей кортежа</span></p>
<p>Этот код напечатает <code>Some numbers: 2, 8, 32</code>, а значения 4 и 16 будут проигнорированы.</p>
<h4 id="Игнорирование-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени"><a class="header" href="#Игнорирование-неиспользуемой-переменной-начинающейся-с-символа-_-в-имени">Игнорирование неиспользуемой переменной, начинающейся с символа <code>_</code> в имени</a></h4>
<p>Если вы создаёте переменную, но нигде её не используете, Rust обычно выдаёт предупреждение, потому что неиспользуемая переменная может быть ошибкой. Но иногда полезно создать переменную, которую вы пока не используете, например, когда вы создаёте прототип или только начинаете проект. В этой ситуации вы можете сказать Rust не предупреждать вас о неиспользуемой переменной, начав имя переменной с подчёркивания. В листинге 18-20 мы создаём две неиспользуемые переменные, но когда мы компилируем такой код, мы должны получить предупреждение только об одной из них.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-20/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-20: Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных</span></p>
<p>Здесь мы получаем предупреждение о том, что не используем переменную <code>y</code>, но мы не получаем предупреждения о неиспользовании переменной<code>_x</code>.</p>
<p>Обратите внимание, что есть небольшая разница между использованием только <code>_</code> и использованием имени, начинающегося с подчёркивания. Синтаксис <code>_x </code> по-прежнему привязывает значение к переменной, тогда как <code>_</code> не привязывает ничего. В листинге 18-21 представлена ошибка, показывающая, в каком случае это различие имеет значение.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-21/src/main.rs:here}}
</code></pre>
<p><span class="caption">Листинг 18-21: Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения</span></p>
<p>Мы получим ошибку, поскольку значение <code>s</code> все равно будет перемещено в <code>_s</code>, что не позволит нам больше воспользоваться <code>s</code>. Однако использование подчёркивания само по себе никогда не приводит к привязке к значению. Листинг 18-22 скомпилируется без ошибок, поскольку <code>s</code> не будет перемещён в <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-22/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-22. Использование подчёркивания не привязывает значение</span></p>
<p>Этот код работает нормально, потому что мы никогда не привязываем <code>s</code> к чему либо; оно не перемещается.</p>
<h4 id="Игнорирование-оставшихся-частей-значения-с-помощью-"><a class="header" href="#Игнорирование-оставшихся-частей-значения-с-помощью-">Игнорирование оставшихся частей значения с помощью <code>..</code></a></h4>
<p>Со значениями, которые имеют много частей, можно использовать синтаксис <code>..</code>, чтобы использовать только некоторые части и игнорировать остальные, избегая необходимости перечислять подчёркивания для каждого игнорируемого значения. Шаблон <code>..</code> игнорирует любые части значения, которые мы явно не сопоставили в остальной частью шаблона. В листинге 18-23 мы имеем структуру <code>Point</code>, которая содержит координату в трёхмерном пространстве. В выражении <code>match</code> мы хотим работать только с координатой <code>x</code> и игнорировать значения полей <code>y</code> и <code>z</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-23/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-21: Игнорирование полей структуры <code>Point</code> кроме поля <code>x</code> с помощью <code>..</code></span></p>
<p>Мы перечисляем значение <code>x</code> и затем просто включаем шаблон <code>..</code>. Это быстрее, чем перечислять <code>y: _</code> и <code>z: _</code>, особенно когда мы работаем со структурами, которые имеют много полей, в ситуациях, когда только одно или два поля представляют для нас интерес.</p>
<p>Синтаксис <code>..</code> раскроется до необходимого количества значений. В листинге 18-24 показано, как использовать <code>..</code> с кортежем.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-24/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-24: Сопоставление только первого и последнего значений в кортеже и игнорирование всех других значений</span></p>
<p>В этом коде первое и последнее значение соответствуют <code>first</code> и <code>last</code>. Конструкция <code>..</code> будет соответствовать и игнорировать всё, что находится между ними.</p>
<p>Однако использование <code>..</code> должно быть однозначным. Если неясно, какие значения предназначены для сопоставления, а какие следует игнорировать, Rust выдаст ошибку. В листинге 18-25 показан пример неоднозначного использования <code>..</code>, поэтому он не будет компилироваться.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-25/src/main.rs}}
</code></pre>
<p><span class="caption">Листинг 18-25: Попытка использовать <code>..</code> неоднозначным способом</span></p>
<p>При компиляции примера, мы получаем эту ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch18-patterns-and-matching/listing-18-25/output.txt}}
</code></pre>
<p>Rust не может определить, сколько значений в кортеже нужно игнорировать, прежде чем сопоставить значение с <code>second</code>, и сколько следующих значений проигнорировать после этого. Этот код может означать, что мы хотим игнорировать <code>2</code>, связать <code>second</code> с <code>4</code>, а затем игнорировать <code>8</code>, <code>16</code> и <code>32</code>; или что мы хотим игнорировать <code>2</code> и <code>4</code>, связать <code>second</code> с <code>8</code>, а затем игнорировать <code>16</code> и <code>32</code>; и так далее. Имя переменной <code>second</code> не означает ничего особенного для Rust, поэтому мы получаем ошибку компилятора, так как использование <code>..</code> в двух местах как здесь, является неоднозначным.</p>
<h3 id="Дополнительные-условия-оператора-сопоставления-match-guards"><a class="header" href="#Дополнительные-условия-оператора-сопоставления-match-guards">Дополнительные условия оператора сопоставления (Match Guards)</a></h3>
<p><em>Условие сопоставления</em> (match guard) является дополнительным условием <code>if</code>, указанным после шаблона в ветке <code>match</code>, которое также должно быть выполнено, чтобы ветка была выбрана. Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.</p>
<p>Условие может использовать переменные, созданные в шаблоне. В листинге 18-26 показан <code>match</code>, в котором первая ветка имеет шаблон <code>Some(x)</code>, а также имеет условие сопоставления, <code>if x % 2 == 0</code> (которое будет истинным, если число чётное).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-26/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-26: Добавление условия сопоставления в шаблон</span></p>
<p>В этом примере будет напечатано <code>The number 4 is even</code>. Когда <code>num</code> сравнивается с шаблоном в первой ветке, он совпадает, потому что <code>Some(4)</code> соответствует <code>Some(x)</code>. Затем условие сопоставления проверяет, равен ли 0 остаток от деления <code>x</code> на 2 и если это так, то выбирается первая ветка.</p>
<p>Если бы <code>num</code> вместо этого было <code>Some(5)</code>, условие в сопоставлении первой ветки было бы ложным, потому что остаток от 5 делённый на 2, равен 1, что не равно 0. Rust тогда перешёл бы ко второй ветке, которое совпадает, потому что вторая ветка не имеет условия сопоставления и, следовательно, соответствует любому варианту <code>Some</code>.</p>
<p>Невозможно выразить условие <code>if x % 2 == 0</code> внутри шаблона, поэтому условие в сопоставлении даёт нам возможность выразить эту логику. Недостатком этой дополнительной выразительности является то, что компилятор не пытается проверять полноту, когда задействованы выражения с условием в сопоставлении.</p>
<p>В листинге 18-11 мы упомянули, что можно использовать условия сопоставления для решения нашей проблемы затенения шаблона. Напомним, что внутри шаблона в выражении <code>match</code> была создана новая переменная, вместо использования внешней к <code>match</code> переменной. Эта новая переменная означала, что мы не могли выполнить сравнение с помощью значения внешней переменной. В листинге 18-27 показано, как мы можем использовать условие сопоставления для решения этой проблемы.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-27/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-27. Использование условия сопоставления для проверки на равенство со значением внешней переменной</span></p>
<p>Этот код теперь напечатает <code>Default case, x = Some(5)</code>. Шаблон во второй ветке не вводит новую переменную <code>y</code>, которая будет затенять внешнюю <code>y</code>, это означает, что теперь можно использовать внешнюю переменную <code>y</code> в условии сопоставления. Вместо указания шаблона как <code>Some(y)</code>, который бы затенял бы внешнюю <code>y</code>, мы указываем <code>Some(n)</code>. Это создаёт новую переменную <code>n</code>, которая ничего не затеняет, так как переменной <code>n</code> нет вне конструкции <code>match</code>.</p>
<p>Условие сопоставления <code>if n == y</code> не является шаблоном и следовательно, не вводит новые переменные. Переменная <code>y</code> <em>и есть</em> внешняя <code>y</code>, а не новая затенённая <code>y</code>, и теперь мы можем искать элемент, который будет иметь то же значение, что и внешняя <code>y</code>, путём сравнения <code>n</code> и <code>y</code>.</p>
<p>Вы также можете использовать оператор <em>или</em> <code>|</code> в условии сопоставления, чтобы указать несколько шаблонов; условие сопоставления будет применяться ко всем шаблонам. В листинге 18-28 показан приоритет комбинирования условия сопоставления с шаблоном, который использует <code>|</code>. Важной частью этого примера является то, что условие сопоставления <code>if y</code> применяется к <code>4</code>, <code>5</code>, <em>и</em> к <code>6</code>, хотя это может выглядеть как будто <code>if y</code> относится только к <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-28/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-28: Комбинирование нескольких шаблонов с условием сопоставления</span></p>
<p>Условие сопоставления гласит, что ветка совпадает, только если значение <code>x</code> равно <code>4</code>, <code>5</code> или <code>6</code>, <em>и</em> если <code>y</code> равно <code>true</code>. Когда этот код выполняется, шаблон первой ветки совпадает, потому что <code>x</code> равно <code>4</code>, но условие сопоставления <code>if y</code> равно false, поэтому первая ветка не выбрана. Код переходит ко второй ветке, которая совпадает, и эта программа печатает <code>no</code>. Причина в том, что условие <code>if</code> применяется ко всему шаблону <code>4 | 5 | 6</code>, а не только к последнему значению <code>6</code>. Другими словами, приоритет условия сопоставления по отношению к шаблону ведёт себя так:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>После запуска кода, старшинство в поведении становится очевидным: если условие сопоставления применялось бы только к конечному значению в списке, указанном с помощью оператора <code>|</code>, то ветка бы совпала и программа напечатала бы <code>yes</code>.</p>
<h3 id="Связывание-"><a class="header" href="#Связывание-">Связывание <code>@</code></a></h3>
<p>Оператор <em>at</em> (<code>@</code>) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение шаблону. В листинге 18-29 показан пример, в котором мы хотим проверить, что перечисление <code>Message::Hello</code> со значением поля <code>id</code> находится в диапазоне <code>3..=7</code>. Но мы также хотим привязать такое значение к переменной <code>id_variable</code>, чтобы использовать его внутри кода данной ветки. Мы могли бы назвать эту переменную <code>id</code>, так же как поле, но для этого примера мы будем использовать другое имя.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch18-patterns-and-matching/listing-18-29/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 18-29: Использование <code>@</code> для привязывания значения в шаблоне, с одновременной его проверкой</span></p>
<p>В этом примере будет напечатано <code>Found an id in range: 5</code>. Указывая <code>id_variable @</code> перед диапазоном <code>3..=7</code>, мы захватываем любое значение, попадающее в диапазон, одновременно проверяя, что это значение соответствует диапазону в шаблоне.</p>
<p>Во второй ветке, где у нас в шаблоне указан только диапазон, код этой ветки не имеет переменной, которая содержит фактическое значение поля <code>id</code>. Значение поля <code>id</code> могло бы быть 10, 11 или 12, но код, соответствующий этому шаблону, не знает, чему оно равно. Код шаблона не может использовать значение из поля <code>id</code>, потому что мы не сохранили значение <code>id</code> в переменной.</p>
<p>В последней ветке, где мы указали переменную без диапазона, у нас есть значение, доступное для использования в коде ветки, в переменной с именем <code>id</code>. Причина в том, что мы использовали упрощённый синтаксис полей структуры. Но мы не применяли никакого сравнения со значением в поле <code>id</code> в этой ветке, как мы это делали в первых двух ветках: любое значение будет соответствовать этому шаблону.</p>
<p>Использование <code>@</code> позволяет проверять значение и сохранять его в переменной в пределах одного шаблона.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Шаблоны Rust очень помогают различать разные виды данных. При использовании их в выражениях <code>match</code>, Rust гарантирует, что ваши шаблоны охватывают все возможные значения, потому что иначе ваша программа не скомпилируется. Шаблоны в инструкциях <code>let</code> и параметрах функций делают такие конструкции более полезными, позволяя разбивать элементы на более мелкие части, одновременно присваивая их значения переменным. Мы можем создавать простые или сложные шаблоны в соответствии с нашими потребностями.</p>
<p>Далее, в предпоследней главе книги, мы рассмотрим некоторые продвинутые аспекты различных возможностей Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch19-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch19-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
