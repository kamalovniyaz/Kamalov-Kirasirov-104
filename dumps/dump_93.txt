<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Макросы - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html" class="active"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Макросы"><a class="header" href="#Макросы">Макросы</a></h2>
<p>Мы использовали макросы, такие как <code>println!</code> на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Термин <em>макрос</em> относится к семейству возможностей в Rust. Это <em>декларативные</em> (declarative) макросы с помощью <code>macro_rules!</code> и три вида <em>процедурных</em> (procedural) макросов:</p>
<ul>
<li>Пользовательские (выводимые) <code>#[derive]</code> макросы, которые указывают код, добавленный с помощью атрибута <code>derive</code>, используемые для структур и перечислений</li>
<li>Макросы подобные атрибутам (attribute-like), которые определяют настраиваемые атрибуты, используемые для любого элемента языка</li>
<li>Похожие на функции (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream</li>
</ul>
<p>Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.</p>
<h3 id="Разница-между-макросами-и-функциями"><a class="header" href="#Разница-между-макросами-и-функциями">Разница между макросами и функциями</a></h3>
<p>По сути, макросы являются способом написания кода, который записывает другой код, что известно как <em>мета программирование</em>. В Приложении C мы обсуждаем атрибут <code>derive</code>, который генерирует за вас реализацию различных типажей. Мы также использовали макросы <code>println!</code> и <code>vec!</code> на протяжении книги. Все эти макросы <em>раскрываются</em> для генерации большего количества кода, чем исходный код написанный вами вручную.</p>
<p>Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.</p>
<p>Сигнатура функции должна объявлять некоторое количество и тип этих параметров имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число параметров: мы можем вызвать <code>println!(&quot;hello&quot;)</code> с одним аргументом или <code>println!(&quot;hello {}&quot;, name)</code> с двумя аргументами. Также макросы раскрываются до того как компилятор интерпретирует смысл кода, поэтому макрос может, например, реализовать типаж заданного типа. Функция этого не может, потому что она вызывается во время выполнения и типаж должен быть реализован во время компиляции.</p>
<p>Обратной стороной реализации макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Rust код, который записывает другой Rust код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.</p>
<p>Другое важное различие между макросами и функциями заключается в том, что вы должны объявить макросы или добавить их в область видимости <em>прежде</em> чем можете вызывать их в файле, в отличии от функций, которые вы можете объявить где угодно и вызывать из любого места.</p>
<h3 id="Декларативные-макросы-с-macro_rules-для-общего-мета-программирования"><a class="header" href="#Декларативные-макросы-с-macro_rules-для-общего-мета-программирования">Декларативные макросы с <code>macro_rules!</code> для общего мета программирования</a></h3>
<p>Наиболее широко используемой формой макросов в Rust являются <em>декларативные макросы</em>. Они также иногда упоминаются как &quot;макросы на примере&quot;, &quot;<code>macro_rules!</code> макрос&quot; или просто &quot;макросы&quot;. По своей сути декларативные макросы позволяют писать нечто похожее на выражение <code>match</code> в  Rust. Как обсуждалось в главе 6, <code>match</code> выражения являются управляющими структурами, которые принимают некоторое выражение, результат значения выражения сопоставляют с шаблонами, а затем запускают код для сопоставляемой ветки. Макросы также сравнивают значение с шаблонами, которые связаны с конкретным кодом: в этой ситуации значение является литералом исходного кода Rust, переданным в макрос. Шаблоны сравниваются со структурами этого исходного кода и при совпадении код, связанный с каждым шаблоном, заменяет код переданный макросу. Все это происходит во время компиляции.</p>
<p>Для определения макроса используется конструкция <code>macro_rules!</code>. Давайте рассмотрим, как использовать <code>macro_rules!</code> глядя на то, как объявлен макрос <code>vec!</code>. В главе 8 рассказано, как можно использовать макрос <code>vec!</code> для создания нового вектора с определёнными значениями. Например, следующий макрос создаёт новый вектор, содержащий три целых числа:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>Мы также могли использовать макрос <code>vec!</code> для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не смогли бы использовать функцию, чтобы сделать то же самое, потому что мы не знали бы заранее количество или тип значений.</p>
<p>В листинге 19-28 приведено несколько упрощённое определение макроса <code>vec!</code>.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-28/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 19-28: Упрощённая версия определения макроса <code>vec!</code></span></p>
<blockquote>
<p>Примечание: фактическое определение макроса <code>vec!</code> в стандартной библиотеке содержит код для предварительного выделения правильного объёма памяти. Этот код является оптимизацией, которую мы здесь не используем, чтобы сделать пример проще.</p>
</blockquote>
<p>Аннотация <code>#[macro_export]</code> указывает, что данный макрос должен быть доступен всякий раз, когда крейт с объявленным макросом, добавлен в область видимости. Без этой аннотации макрос нельзя добавить в область видимости.</p>
<p>Затем мы начинаем объявление макроса с помощью  <code>macro_rules!</code> и имени макроса, который объявляется <em>без</em> восклицательного знака. Название, в данном случае <code>vec</code>, после которого следуют фигурные скобки, указывающие тело определения макроса.</p>
<p>Структура в теле макроса <code>vec!</code> похожа на структуру <code>match</code> выражения. Здесь у нас есть одна ветвь с шаблоном <code>( $( $x:expr ),* )</code>, затем следует ветвь <code>=&gt;</code> и блок кода, связанный с этим шаблоном. Если шаблон сопоставлен успешно, то соответствующий блок кода будет сгенерирован. Учитывая, что данный код является единственным шаблоном в этом макросе, существует только один действительный способ сопоставления, любой другой шаблон приведёт к ошибке. Более сложные макросы будут иметь более одной ветви.</p>
<p>Допустимый синтаксис шаблона в определениях макросов отличается от синтаксиса шаблона рассмотренного в главе 18, потому что шаблоны макроса сопоставляются со структурами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части шаблона в листинге 19-28 что означают; полный синтаксис шаблонов макроса можно найти в <a href="../reference/macros-by-example.html">Справочнике по Rust</a>.</p>
<p>Во-первых, мы используем набор скобок, чтобы охватить весь шаблон. Мы используем знак доллара ( <code>$</code>) для объявления переменной в системе макросов, которая будет содержать код на Rust, соответствующий шаблону. Знак доллара показывает, что это макропеременная, а не обычная переменная Rust. Далее следует набор скобок, в котором фиксируются значения, соответствующие шаблону в скобках, для использования в коде замены. Внутри <code>$()</code> находится <code>$x:expr</code>, которое соответствует любому выражению Rust и даёт выражению имя <code>$x</code>.</p>
<p>Запятая, следующая за <code>$()</code> указывает на то, что буквенный символ-разделитель запятая может дополнительно появиться после кода, который соответствует коду в <code>$()</code>. Звёздочка <code>*</code> указывает, что шаблон соответствует ноль или больше раз тому, что предшествует <code>*</code>.</p>
<p>Когда вызывается этот макрос с помощью <code>vec![1, 2, 3];</code> шаблон <code>$x</code> соответствует три раза всем трём выражениям <code>1</code>, <code>2</code> и <code>3</code>.</p>
<p>Теперь давайте посмотрим на шаблон в теле кода, связанного с этой ветвью: <code>temp_vec.push()</code> внутри <code>$()*</code> генерируется для каждой части, которая соответствует символу <code>$()</code> в шаблоне ноль или более раз в зависимости от того, сколько раз шаблон сопоставлен. Символ <code>$x</code> заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с <code>vec![1, 2, 3];</code>, сгенерированный код, заменяющий этот вызов макроса будет следующим:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>Мы определили макрос, который может принимать любое количество аргументов любого типа и может генерировать код для создания вектора, содержащего указанные элементы.</p>
<p>Чтобы узнать больше о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как <a href="https://veykril.github.io/tlborm/">«Маленькая книга макросов Rust»</a> , начатая Дэниелом Кипом и продолженная Лукасом Виртом.</p>
<h3 id="Процедурные-макросы-для-генерации-кода-из-атрибутов"><a class="header" href="#Процедурные-макросы-для-генерации-кода-из-атрибутов">Процедурные макросы для генерации кода из атрибутов</a></h3>
<p>Вторая форма макросов - это <em>процедурные макросы</em> (procedural macros), которые действуют как функции (и являются типом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с шаблонами и замену кода другим кодом, как это делают декларативные макросы. Процедурные макросы могут быть трёх типов: &quot;пользовательского вывода&quot; (custom-derive), &quot;похожие на атрибут&quot; (attribute-like) и &quot;похожие на функцию&quot; (function-like), все они работают схожим образом.</p>
<p>При создании процедурных макросов объявления должны находиться в собственном крейте специального типа. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. В листинге 19-29 показано, как задать процедурный макрос, где <code>some_attribute</code> является заполнителем для использования специального макроса.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Листинг 19-29: Пример определения процедурного макроса</span></p>
<p>Функция, которая определяет процедурный макрос, принимает <code>TokenStream</code> в качестве входных данных и создаёт <code>TokenStream</code> в качестве вывода. Тип <code>TokenStream</code> объявлен крейтом <code>proc_macro</code>, включённым в Rust и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным <code>TokenStream</code>, а код создаваемый макросом является выходным <code>TokenStream</code>. К функции имеет также прикреплённый атрибут, определяющий какой тип процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же крейте.</p>
<p>Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие формы отличающимися.</p>
<h3 id="Как-написать-пользовательский-derive-макрос"><a class="header" href="#Как-написать-пользовательский-derive-макрос">Как написать пользовательский <code>derive</code> макрос</a></h3>
<p>Давайте создадим крейт с именем <code>hello_macro</code>, который определяет типаж с именем <code>HelloMacro</code> и имеет одну с ним ассоциированную функцию с именем <code>hello_macro</code>. Вместо того, чтобы пользователи нашего крейта самостоятельно реализовывали типаж <code>HelloMacro</code> для каждого из своих типов, мы предоставим им процедурный макрос, чтобы они могли аннотировать свой тип с помощью атрибута <code>#[derive(HelloMacro)]</code> и получили реализацию по умолчанию для функции <code>hello_macro</code>. Реализация по умолчанию выведет <code>Hello, Macro! My name is TypeName!</code>, где <code>TypeName</code> - это имя типа, для которого был определён этот типаж. Другими словами, мы напишем крейт, использование которого позволит другому программисту писать код показанный в листинге 19-30.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-30/src/main.rs}}
</code></pre>
<p><span class="caption">Листинг 19-30: Код, который сможет писать пользователь нашего крейта при использовании нашего процедурного макроса</span></p>
<p>Этот код напечатает <code>Hello, Macro! My name is Pancakes!</code>, когда мы закончим. Первый шаг - создать новый, библиотечный крейт так:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Далее, мы определим типаж <code>HelloMacro</code> и ассоциированную с ним функцию:</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/hello_macro/src/lib.rs}}
</code></pre>
<p>У нас есть типаж и его функция. На этом этапе пользователь крейта может реализовать типаж для достижения желаемой функциональности, так:</p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-20-impl-hellomacro-for-pancakes/pancakes/src/main.rs}}
</code></pre>
<p>Тем не менее, ему придётся написать блок реализации для каждого типа, который он хотел использовать вместе с <code>hello_macro</code>; а мы хотим избавить их от необходимости делать эту работу.</p>
<p>Кроме того, мы пока не можем предоставить функцию <code>hello_macro</code> с реализацией по умолчанию, которая будет печатать имя типа, для которого реализован типаж: Rust не имеет возможностей рефлексии (reflection), поэтому он не может выполнить поиск имени типа во время выполнения кода. Нам нужен макрос для генерации кода во время компиляции.</p>
<p>Следующим шагом является определение процедурного макроса. На момент написания этой статьи процедурные макросы должны быть в собственном крейте. Со временем это ограничение может быть отменено. Соглашение о структурировании крейтов и макросов является следующим: для крейта с именем <code>foo</code>, его пользовательский, крейт с выводимым процедурным макросом называется <code>foo_derive</code>. Давайте начнём с создания нового крейта с именем <code>hello_macro_derive</code> внутри проекта <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Наши два крейта тесно связаны, поэтому мы создаём процедурный макрос-крейт в каталоге крейта <code>hello_macro</code>. Если мы изменим определение типажа в <code>hello_macro</code>, то нам придётся также изменить реализацию процедурного макроса в <code>hello_macro_derive</code>. Два крейта нужно будет опубликовать отдельно и программисты, использующие эти крейты, должны будут добавить их как зависимости, а затем добавить их в область видимости. Мы могли вместо этого сделать так, что крейт <code>hello_macro</code> использует <code>hello_macro_derive</code> как зависимость и реэкспортирует код процедурного макроса. Однако то, как мы структурировали проект, делает возможным программистам использовать <code>hello_macro</code> даже если они не хотят <code>derive</code> функциональность.</p>
<p>Нам нужно объявить крейт <code>hello_macro_derive</code> как процедурный макрос-крейт. Также понадобятся функционал из крейтов <code>syn</code> и <code>quote</code>, как вы увидите через мгновение, поэтому нам нужно добавить их как зависимости. Добавьте следующее в файл <em>Cargo.toml</em> для <code>hello_macro_derive</code>:</p>
<p><span class="filename">Файл: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">{{#include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/Cargo.toml:6:12}}
</code></pre>
<p>Чтобы начать определение процедурного макроса, поместите код листинга 19-31 в ваш файл <em>src/lib.rs</em> крейта <code>hello_macro_derive</code>. Обратите внимание, что этот код не скомпилируется пока мы не добавим определение для функции <code>impl_hello_macro</code>.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-31/hello_macro/hello_macro_derive/src/lib.rs}}
</code></pre>
<p><span class="caption">Листинг 19-31: Код, который потребуется в большинстве процедурных макро крейтов для обработки Rust кода</span></p>
<p>Обратите внимание, что мы разделили код на функцию <code>hello_macro_derive</code>, которая отвечает за синтаксический анализ <code>TokenStream</code> и функцию <code>impl_hello_macro</code>, которая отвечает за преобразование синтаксического дерева: это делает написание процедурного макроса удобнее. Код во внешней функции ( <code>hello_macro_derive</code> в данном случае) будет одинаковым для почти любого процедурного макрос крейта, который вы видите или создаёте. Код, который вы указываете в теле внутренней функции (в данном случае <code>impl_hello_macro</code> ) будет отличаться в зависимости от цели вашего процедурного макроса.</p>
<p>Мы представили три новых крейта: <code>proc_macro</code> <a href="https://crates.io/crates/syn"><code>syn</code></a> и <a href="https://crates.io/crates/quote"><code>quote</code></a>. Макрос <code>proc_macro</code> поставляется с Rust, поэтому нам не нужно было добавлять его в зависимости внутри <em>Cargo.toml</em>. Макрос <code>proc_macro</code> - это API компилятора, который позволяет нам читать и манипулировать Rust кодом из нашего кода.</p>
<p>Крейт <code>syn</code> разбирает Rust код из строки в структуру данных над которой мы может выполнять операции. Крейт <code>quote</code> превращает структуры данных <code>syn</code> обратно в код Rust. Эти крейты упрощают разбор любого вида Rust кода, который мы хотели бы обрабатывать: написание полного синтаксического анализатора для кода Rust не является простой задачей.</p>
<p>Функция <code>hello_macro_derive</code> будет вызываться, когда пользователь нашей библиотеки указывает своему типу <code>#[derive(HelloMacro)]</code>. Это возможно, потому что мы аннотировали функцию <code>hello_macro_derive</code> с помощью <code>proc_macro_derive</code> и указали имя <code>HelloMacro</code>, которое соответствует имени нашего типажа; это соглашение, которому следует большинство процедурных макросов.</p>
<p>Функция <code>hello_macro_derive</code> сначала преобразует <code>input</code> из <code>TokenStream</code> в структуру данных, которую мы можем затем интерпретировать и над которой выполнять операции. Здесь крейт <code>syn</code> вступает в игру. Функция <code>parse</code> в <code>syn</code> принимает <code>TokenStream</code> и возвращает структуру <code>DeriveInput</code>, представляющую разобранный код Rust. Листинг 19-32 показывает соответствующие части структуры <code>DeriveInput</code>, которые мы получаем при разборе строки <code>struct Pancakes;</code>:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Листинг 19-32: Экземпляр <code>DeriveInput</code> получаемый, когда разбирается код имеющий атрибут макроса из листинга 19-30</span></p>
<p>Поля этой структуры показывают, что код Rust, который мы разобрали, является блок структуры с <code>ident</code> (идентификатором, означающим имя) <code>Pancakes</code>. В этой структуре есть больше полей для описания всех видов кода Rust; проверьте <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">документацию <code>syn</code> о структуре <code>DeriveInput</code></a> для получения дополнительной информации.</p>
<p>Вскоре мы определим функцию <code>impl_hello_macro</code>, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является <code>TokenStream</code>. Возвращаемый <code>TokenStream</code> добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой крейт, они получат дополнительную функциональность, которую мы предоставляем в изменённом <code>TokenStream</code>.</p>
<p>Возможно, вы заметили, что мы вызываем <code>unwrap</code> чтобы выполнить панику в функции <code>hello_macro_derive</code>, если вызов функции <code>syn::parse</code> потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции <code>proc_macro_derive</code> должны возвращать <code>TokenStream</code>, а не тип <code>Result</code> для соответствия API процедурного макроса. Мы упростили этот пример с помощью <code>unwrap</code>, но в рабочем коде вы должны предоставить более конкретные сообщения об ошибках, если что-то пошло не правильно, используя <code>panic!</code> или <code>expect</code>.</p>
<p>Теперь, когда у нас есть код для преобразования аннотированного Rust кода из <code>TokenStream</code> в экземпляр <code>DeriveInput</code>, давайте сгенерируем код реализующий типаж <code>HelloMacro</code> у аннотированного типа, как показано в листинге 19-33.</p>
<p><span class="filename">Файл: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-33/hello_macro/hello_macro_derive/src/lib.rs:here}}
</code></pre>
<p><span class="caption">Листинг 19-33: Реализация типажа <code>HelloMacro</code> с использованием проанализированного кода Rust.</span></p>
<p>Мы получаем экземпляр структуры <code>Ident</code> содержащий имя (идентификатор) аннотированного типа с использованием <code>ast.ident</code>. Структура в листинге 19-32 показывает, что когда мы запускаем функцию <code>impl_hello_macro</code> для кода из листинга 19-30, то получаемый <code>ident</code> будет иметь поле <code>ident</code> со значением <code>&quot;Pancakes&quot;</code>. Таким образом, переменная <code>name</code> в листинге 19-33 будет содержать экземпляр структуры <code>Ident</code>, что при печати выдаст строку <code>&quot;Pancakes&quot;</code>, что является именем структуры в листинге 19-30.</p>
<p>Макрос <code>quote!</code> позволяет определить код Rust, который мы хотим вернуть. Компилятор ожидает что-то отличное от прямого результата выполнения макроса <code>quote!</code>, поэтому нужно преобразовать его в <code>TokenStream</code>. Мы делаем это путём вызова метода <code>into</code>, который использует промежуточное представление и возвращает значение требуемого типа <code>TokenStream</code>.</p>
<p>Макрос <code>quote!</code> также предоставляет очень классную механику шаблонов: мы можем ввести <code>#name</code> и <code>quote!</code> заменит его значением из переменной <code>name</code>. Вы можете даже сделать некоторое повторение, подобное тому, как работают обычные макросы. Проверьте <a href="https://docs.rs/quote">документацию крейта <code>quote</code></a> для подробного введения.</p>
<p>Мы хотим, чтобы наш процедурный макрос генерировал реализацию нашего типажа <code>HelloMacro</code> для типа, который аннотировал пользователь, который мы можем получить, используя <code>#name</code>. Реализация типажа имеет одну функцию <code>hello_macro</code>, тело которой содержит функциональность, которую мы хотим предоставить: напечатать <code>Hello, Macro! My name is</code> с именем аннотированного типа.</p>
<p>Макрос <code>stringify!</code> используемый здесь, встроен в Rust. Он принимает Rust выражение, такое как <code>1 + 2</code> и во время компиляции компилятор превращает выражение в строковый литерал, такой как <code>&quot;1 + 2&quot;</code>. Он отличается от макросов <code>format!</code> или <code>println!</code>, которые вычисляют выражение, а затем превращают результат в виде типа <code>String</code>. Существует возможность того, что введённый <code>#name</code> может оказаться выражением для печати буквально как есть, поэтому здесь мы используем <code>stringify!</code>. Использование <code>stringify!</code> также экономит выделение памяти путём преобразования <code>#name</code> в строковый литерал во время компиляции.</p>
<p>На этом этапе команда <code>cargo build</code> должна завершиться успешно для обоих <code>hello_macro</code> и <code>hello_macro_derive</code>. Давайте подключим эти крейты к коду в листинге 19-30, чтобы увидеть процедурный макрос в действии! Создайте новый бинарный проект в каталоге ваших <em>проектов</em> с использованием команды <code>cargo new pancakes</code>. Нам нужно добавить <code>hello_macro</code> и <code>hello_macro_derive</code> в качестве зависимостей для крейта <code>pancakes</code> в файл <em>Cargo.toml</em>. Если вы публикуете свои версии <code>hello_macro</code> и <code>hello_macro_derive</code> на сайт <a href="https://crates.io/">crates.io</a>, они будут обычными зависимостями; если нет, вы можете указать их как <code>path</code> зависимости следующим образом:</p>
<pre><code class="language-toml">{{#include ../listings/ch19-advanced-features/no-listing-21-pancakes/pancakes/Cargo.toml:7:9}}
</code></pre>
<p>Поместите код в листинге 19-30 в <em>src/main.rs</em> и выполните <code>cargo run</code>: он должен вывести <code>Hello, Macro! My name is Pancakes!</code>. Реализация типажа <code>HelloMacro</code> из процедурного макроса была включена без необходимости его реализации крейтом <code>pancakes</code>; <code>#[derive(HelloMacro)]</code> добавил реализацию типажа.</p>
<p>Далее давайте рассмотрим, как другие виды процедурных макросов отличаются от пользовательских выводимых макросов.</p>
<h3 id="Макросы-похожие-на-атрибут"><a class="header" href="#Макросы-похожие-на-атрибут">Макросы, похожие на атрибут</a></h3>
<p>Подобные атрибутам макросы похожи на пользовательские выводимые макросы, но вместо генерации кода для <code>derive</code> атрибута, они позволяют создавать новые атрибуты. Они являются также более гибкими: <code>derive</code> работает только для структур и перечислений; атрибут-подобные могут применяться и к другим элементам, таким как функции. Вот пример использования  атрибутного макроса: допустим, у вас есть атрибут именованный <code>route</code> который аннотирует функции при использовании фреймворка для веб-приложений:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>Данный атрибут <code>#[route]</code> будет определён платформой как процедурный макрос. Сигнатура функции определения макроса будет выглядеть так:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Здесь есть два параметра типа <code>TokenStream</code>. Первый для содержимого атрибута: часть <code>GET, &quot;/&quot;</code> . Второй это тело элемента, к которому прикреплён атрибут: в данном случае <code>fn index() {}</code> и остальная часть тела функции.</p>
<p>Кроме того, атрибутные макросы работают так же как и пользовательские выводимые макросы: вы создаёте крейт с типом <code>proc-macro</code> и реализуете функцию, которая генерирует код, который хотите!</p>
<h3 id="Макросы-похожие-на-функции"><a class="header" href="#Макросы-похожие-на-функции">Макросы, похожие на функции</a></h3>
<p>Макросы, похожие на функции, выглядят подобно вызову функций. Подобно макросам <code>macro_rules!</code> они являются более гибкими, чем функции; например, они могут принимать неизвестное количество аргументов. Тем не менее, макросы <code>macro_rules!</code> можно объявлять только с использованием синтаксиса подобного сопоставлению, который мы обсуждали ранее в разделе <a data-md-type="raw_html" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">&quot;Декларативные макросы <code>macro_rules!</code> для общего мета программирования&quot;</a>. Макросы, похожие на функции, принимают параметр <code>TokenStream</code> и их определение манипулирует этим <code>TokenStream</code>, используя код Rust, как это делают два других типа процедурных макроса. Примером подобного функционально подобного макроса является макрос <code>sql!</code>, который можно вызвать так:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>Этот макрос будет разбирать SQL инструкцию внутри него и проверять, что она синтаксически правильная, что является гораздо более сложной обработкой, чем то что может сделать макрос <code>macro_rules!</code>. Макрос <code>sql!</code> мог бы быть определён так:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Это определение похоже на сигнатуру пользовательского выводимого макроса: мы получаем токены, которые находятся внутри скобок и возвращаем код, который мы хотели сгенерировать.</p>
<h2 id="Итоги"><a class="header" href="#Итоги">Итоги</a></h2>
<p>Фух! Теперь у вас в распоряжении есть некоторые возможности Rust, которые вы не будете часто использовать, но вы будете знать, что они доступны в особых обстоятельствах. Мы представили несколько сложных тем, чтобы при появлении сообщения с предложением исправить ошибку или в коде других людей, вы могли бы распознать эти концепции и синтаксис. Используйте эту главу как справочник, который поможет вам найти решение.</p>
<p>Далее мы применим на практике все, что обсуждали на протяжении всей книги, и выполним ещё один проект!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch20-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch20-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
