<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Небезопасный код в Rust - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>Во всех предыдущих главах этой книги мы обсуждали код на Rust, безопасность памяти в котором гарантируется во время компиляции. Однако внутри Rust скрывается другой язык - небезопасный Rust, который не обеспечивает безопасной работы с памятью. Этот язык называется <em>unsafe Rust</em> и работает также как и первый, но предоставляет вам дополнительные возможности.</p>
<p>Небезопасный Rust существует потому что по своей природе статический анализ довольно консервативен. Когда компилятор пытается определить, соответствует ли код гарантиям, то он скорее отвергнет несколько допустимых программ, чем пропустит несколько недопустимых. Не смотря на то, что код <em>может</em> быть в порядке, если компилятор Rust не будет располагать достаточной информацией, чтобы убедиться в этом, он отвергнет код. В таких случаях вы можете использовать небезопасный код, чтобы сказать компилятору: &quot;Поверь мне, я знаю, что делаю&quot;. Однако имейте в виду, что вы используете небезопасный Rust на свой страх и риск: если вы неправильно используете небезопасный код, могут возникнуть проблемы, связанные с нарушением безопасности памяти, например, разыменование нулевого указателя.</p>
<p>Другая причина, по которой у Rust есть небезопасное альтер эго, заключается в том, что по существу аппаратное обеспечение компьютера небезопасно. Если Rust не позволял бы вам выполнять небезопасные операции, вы не могли бы выполнять определённые задачи. Rust должен позволить вам использовать системное, низкоуровневое программирование, такое как прямое взаимодействие с операционной системой, или даже написание вашей собственной операционной системы. Возможность написания низкоуровневого, системного кода является одной из целей языка. Давайте рассмотрим, что и как можно делать с небезопасным Rust.</p>
<h3 id="Небезопасные-сверхспособности"><a class="header" href="#Небезопасные-сверхспособности">Небезопасные сверхспособности</a></h3>
<p>Чтобы переключиться на небезопасный Rust, используйте ключевое слово <code>unsafe</code>, а затем начните новый блок, содержащий небезопасный код. В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем <em>небезопасными супер силами</em>. Эти супер силы включают в себя следующее:</p>
<ul>
<li>Разыменование сырого указателя</li>
<li>Вызов небезопасной функции или небезопасного метода</li>
<li>Доступ или изменение изменяемой статической переменной</li>
<li>Реализация небезопасного типажа</li>
<li>Доступ к полям в <code>union</code></li>
</ul>
<p>Важно понимать, что <code>unsafe</code> не отключает проверку заимствования или любые другие проверки безопасности Rust: если вы используете ссылку в небезопасном коде, она всё равно будет проверена. Единственное, что делает ключевое слово <code>unsafe</code> - даёт вам доступ к этим пяти возможностям, безопасность работы с памятью в которых не проверяет компилятор. Вы по-прежнему получаете некоторую степень безопасности внутри небезопасного блока.</p>
<p>Кроме того, <code>unsafe</code> не означает, что код внутри этого блока является неизбежно опасным или он точно будет иметь проблемы с безопасностью памяти: цель состоит в том, что вы, как программист, гарантируете, что код внутри блока <code>unsafe</code> будет обращаться к действительной памяти корректным образом.</p>
<p>Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных операции внутри блоков, помеченных как <code>unsafe</code>, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри <code>unsafe</code> блоков. Делайте <code>unsafe</code> блоки маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.</p>
<p>Чтобы максимально изолировать небезопасный код, рекомендуется заключить небезопасный код в безопасную абстракцию и предоставить безопасный API, который мы обсудим позже, когда будем обсуждать небезопасные функции и методы. Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом. Оборачивание небезопасного кода в безопасную абстракцию предотвращает возможную утечку использования <code>unsafe</code> кода во всех местах, где вы или ваши пользователи могли бы захотеть напрямую использовать функциональность, реализованную <code>unsafe</code> кодом, потому что использование безопасной абстракции само безопасно.</p>
<p>Давайте поговорим о каждой из четырёх небезопасных сверх способностей, и по ходу дела рассмотрим некоторые абстракции, которые обеспечивают безопасный интерфейс для небезопасного кода.</p>
<h3 id="Разыменование-сырых-указателей"><a class="header" href="#Разыменование-сырых-указателей">Разыменование сырых указателей</a></h3>
<p>В главе 4 раздела <a href="ch04-02-references-and-borrowing.html#dangling-references">&quot;Недействительные ссылки&quot;</a><!--  --> мы упоминали, что компилятор гарантирует, что ссылки всегда действительны. Небезопасный Rust имеет два новых типа, называемых <em>сырыми указателями</em> (raw pointers), которые похожи на ссылки. Как и в случае ссылок, сырые указатели могут быть неизменяемыми или изменяемыми и записываться как <code>*const T</code> и <code>*mut T</code> соответственно. Звёздочка не является оператором разыменования; это часть имени типа. В контексте сырых указателей <em>неизменяемый</em> (immutable) означает, что указателю нельзя напрямую присвоить что-то после того как он разыменован.</p>
<p>В отличие от ссылок и умных указателей, сырые указатели:</p>
<ul>
<li>могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти</li>
<li>не гарантируют что ссылаются на действительную память</li>
<li>могут быть null</li>
<li>не реализуют автоматическую очистку памяти</li>
</ul>
<p>Отказавшись от этих гарантий, вы можете обменять безопасность  на большую производительность или возможность взаимодействия с другим языком или оборудованием, где гарантии Rust не применяются.</p>
<p>В листинге 19-1 показано, как создать неизменяемый и изменяемый сырой указатель из ссылок.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-01/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-1: Создание необработанных указателей из ссылок</span></p>
<p>Обратите внимание, что мы не используем ключевое слово <code>unsafe</code> в этом коде. Можно создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырые указатели за пределами небезопасного блока, как вы увидите чуть позже.</p>
<p>Мы создали сырые указатели, используя <code>as</code> для приведения неизменяемой и изменяемой ссылки к соответствующим им типам сырых указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно являются действительными, мы знаем, что эти конкретные сырые указатели являются действительными, но мы не можем делать такое же предположение о любом сыром указателе.</p>
<p>Чтобы продемонстрировать это, создадим сырой указатель, в достоверности которого мы не можем быть так уверены. В листинге 19-2 показано, как создать необработанный указатель на произвольное место в памяти. Попытка использовать произвольную память является непредсказуемой: по этому адресу могут быть данные, а могут и не быть, компилятор может оптимизировать код так, что доступа к памяти не будет, или программа может завершиться с ошибкой сегментации. Обычно нет веских причин писать такой код, но это возможно.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-02/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-2: Создание сырого указателя на произвольный адрес памяти</span></p>
<p>Напомним, что можно создавать сырые указатели в безопасном коде, но нельзя <em>разыменовывать</em> сырые указатели и читать данные, на которые они указывают. В листинге 19-3 мы используем оператор разыменования <code>*</code> для сырого указателя, который требует <code>unsafe</code> блока.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-03/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-3: Разыменование сырых указателей в блоке <code>unsafe</code></span></p>
<p>Создание указателей безопасно. Только при попытке доступа к объекту по адресу в указателе мы можем получить недопустимое значение.</p>
<p>Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали <code>*const i32</code> и <code>*mut i32</code>, которые ссылаются на одну и ту же область памяти, где хранится <code>num</code>. Если мы попытаемся создать неизменяемую и изменяемую ссылку на <code>num</code> вместо сырых указателей, такой код не скомпилируется, т.к. будут нарушены правила заимствования, запрещающие наличие изменяемой ссылки одновременно с неизменяемыми ссылками. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый указатель на одну и ту же область памяти и изменять данные с помощью изменяемого указателя, потенциально создавая эффект гонки данных. Будьте осторожны!</p>
<p>С учётом всех этих опасностей, зачем тогда использовать сырые указатели? Одним из основных применений является взаимодействие с кодом C, как вы увидите в следующем разделе <a href="#calling-an-unsafe-function-or-method">&quot;Вызов небезопасной функции или метода&quot;</a><!--  -->. Другой случай это создание безопасных абстракций, которые не понимает анализатор заимствований. Мы введём понятие небезопасных функций и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.</p>
<h3 id="Вызов-небезопасной-функции-или-метода"><a class="header" href="#Вызов-небезопасной-функции-или-метода">Вызов небезопасной функции или метода</a></h3>
<p>Второй тип операций, которые можно выполнять в небезопасном блоке - это вызов небезопасных функций. Небезопасные функции и методы выглядят точно так же, как обычные функции и методы, но перед остальным определением у них есть дополнительное <code>unsafe</code>. Ключевое слово <code>unsafe</code> в данном контексте указывает на то, что к функции предъявляются требования, которые мы должны соблюдать при вызове этой функции, поскольку Rust не может гарантировать, что мы их выполняем. Вызывая небезопасную функцию внутри блока <code>unsafe</code>, мы говорим, что прочитали документацию к этой функции и берём на себя ответственность за соблюдение её условий.</p>
<p>Вот небезопасная функция с именем <code>dangerous</code> которая ничего не делает в своём теле:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/no-listing-01-unsafe-fn/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p>Мы должны вызвать функцию <code>dangerous</code> в отдельном <code>unsafe</code> блоке. Если мы попробуем вызвать <code>dangerous</code> без <code>unsafe</code> блока, мы получим ошибку:</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/output-only-01-missing-unsafe/output.txt}}
</code></pre>
<p>С помощью блока <code>unsafe</code> мы сообщаем Rust, что прочитали документацию к функции, поняли, как правильно её использовать, и убедились, что выполняем контракт функции.</p>
<p>Тела небезопасных функций являются фактически <code>unsafe</code> блоками, поэтому для выполнения других небезопасных операций внутри небезопасной функции не нужно добавлять ещё один <code>unsafe</code> блок.</p>
<h4 id="Создание-безопасных-абстракций-вокруг-небезопасного-кода"><a class="header" href="#Создание-безопасных-абстракций-вокруг-небезопасного-кода">Создание безопасных абстракций вокруг небезопасного кода</a></h4>
<p>То, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. На самом деле, обёртывание небезопасного кода в безопасную функцию - это обычная абстракция. В качестве примера рассмотрим функцию <code>split_at_mut</code> из стандартной библиотеки, которая требует некоторого небезопасного кода. Рассмотрим, как мы могли бы её реализовать. Этот безопасный метод определён для изменяемых срезов: он берет один срез и превращает его в два, разделяя срез по индексу, указанному в качестве аргумента. В листинге 19-4 показано, как использовать <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-04/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-4: Использование безопасной функции <code>split_at_mut</code></span></p>
<p>Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации могла бы выглядеть примерно как в листинге 19-5, который не компилируется. Для простоты мы реализуем <code>split_at_mut</code> как функцию, а не как метод, и только для значений типа <code>i32</code>, а не обобщённого типа <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-05/src/main.rs:here}}
</code></pre>
<p><span class="caption">Листинг 19-5: Попытка реализации <code>split_at_mut</code> с использованием только безопасного Rust</span></p>
<p>Эта функция сначала получает общую длину среза. Затем она проверяет (assert), что индекс, переданный в качестве параметра, находится в границах среза, сравнивая его с длиной. Assert означает, что если мы передадим индекс, который больше, чем длина среза, функция запаникует ещё до попытки использования этого индекса.</p>
<p>Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до <code>mid</code> индекса (не включая сам mid), а другой - от <code>mid</code> (включая сам mid) до конца фрагмента.</p>
<p>При попытке скомпилировать код в листинге 19-5, мы получим ошибку.</p>
<pre><code class="language-console">{{#include ../listings/ch19-advanced-features/listing-19-05/output.txt}}
</code></pre>
<p>Анализатор заимствований Rust не может понять, что мы заимствуем различные части среза, он понимает лишь, что мы хотим осуществить заимствование частей одного среза дважды. Заимствование различных частей среза в принципе нормально, потому что они не перекрываются, но Rust недостаточно умён, чтобы это понять. Когда мы знаем, что код верный, но Rust этого не понимает, значит пришло время прибегнуть к небезопасному коду.</p>
<p>Листинг 19-6 демонстрирует, как можно использовать <code>unsafe</code> блок, сырой указатель и вызовы небезопасных функций чтобы <code>split_at_mut</code> заработала:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-06/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-6. Использование небезопасного кода в реализации функции <code>split_at_mut</code></span></p>
<p>Напомним, из раздела <a href="ch04-03-slices.html#the-slice-type">&quot;Тип срез&quot;</a><!-- ignore --> главы 4, что срезы состоят из указателя на некоторые данные и длины. Мы используем метод <code>len</code> для получения длины среза и метод <code>as_mut_ptr</code> для доступа к сырому указателю среза. Поскольку у нас есть изменяемый срез на значения типа <code>i32</code>, функция <code>as_mut_ptr</code> возвращает сырой указатель типа <code>*mut i32</code>, который мы сохранили в переменной <code>ptr</code>.</p>
<p>Далее проверяем, что индекс <code>mid</code> находится в границах среза. Затем мы обращаемся к небезопасному коду: функция <code>slice::from_raw_parts_mut</code> принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с <code>ptr</code> и имеющего длину в <code>mid</code> элементов. Затем мы вызываем метод <code>add</code> у <code>ptr</code> с <code>mid</code> в качестве аргумента, чтобы получить сырой указатель, который начинается с <code>mid</code>, и создаём срез, используя этот указатель и оставшееся количество элементов после <code>mid</code> в качестве длины.</p>
<p>Функция <code>slice::from_raw_parts_mut</code> является небезопасной, потому что она принимает необработанный указатель и должна полагаться на то, что этот указатель действителен. Метод <code>add</code> для необработанных указателей также небезопасен, поскольку он должен считать, что местоположение смещения также является действительным указателем. Поэтому мы были вынуждены разместить <code>unsafe</code> блок вокруг наших вызовов <code>slice::from_raw_parts_mut</code> и <code>add</code>, чтобы иметь возможность вызвать их. Посмотрев на код и добавив утверждение, что <code>mid</code> должен быть меньше или равен <code>len</code>, мы можем сказать, что все необработанные указатели, используемые в блоке <code>unsafe</code>, будут корректными указателями на данные внутри среза. Это приемлемое и уместное использование <code>unsafe</code>.</p>
<p>Обратите внимание, что нам не нужно помечать результирующую функцию <code>split_at_mut</code> как <code>unsafe</code>, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью реализации функции, которая использует код <code>unsafe</code> блока безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.</p>
<p>Напротив, использование <code>slice::from_raw_parts_mut</code> в листинге 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-07/src/main.rs:here}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-7: Создание среза из произвольного адреса памяти</span></p>
<p>Мы не владеем памятью в этом произвольном месте, и нет никакой гарантии, что созданный этим кодом фрагмент содержит допустимые значения <code>i32</code>. Попытка использовать <code>values</code> так, как будто это допустимый срез, приводит к неопределённому поведению.</p>
<h4 id="Использование-extern-функций-для-вызова-внешнего-кода"><a class="header" href="#Использование-extern-функций-для-вызова-внешнего-кода">Использование <code>extern</code> функций для вызова внешнего кода</a></h4>
<p>Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово <code>extern</code>, которое облегчает создание и использование <em>интерфейса внешних функций (Foreign Function Interface - FFI)</em>. FFI - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.</p>
<p>Листинг 19-8 демонстрирует, как настроить интеграцию с функцией <code>abs</code> из стандартной библиотеки C. Функции, объявленные внутри блоков <code>extern</code>, всегда небезопасны для вызова из кода Rust. Причина в том, что другие языки не обеспечивают соблюдение правил и гарантий Rust, Rust также не может проверить гарантии, поэтому ответственность за безопасность ложится на программиста.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-08/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-8: Объявление и вызов <code>extern</code> функции, написанной на другом языке программирования</span></p>
<p>Внутри блока <code>extern &quot;C&quot;</code> мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть <code>&quot;C&quot;</code> определяет какой <em>application binary interface</em> (ABI - бинарный интерфейс приложений) использует внешняя функция. Интерфейс ABI определяет как вызвать функцию на уровне ассемблера. Использование ABI <code>&quot;C&quot;</code> является наиболее часто используемым и следует правилам ABI интерфейса языка Си.</p>
<blockquote>
<h4 id="Вызов-функций-rust-из-других-языков"><a class="header" href="#Вызов-функций-rust-из-других-языков">Вызов функций Rust из других языков</a></h4>
<p>Также можно использовать <code>extern</code> для создания интерфейса, позволяющего другим языкам вызывать функции Rust. Вместо того чтобы создавать целый блок <code>extern</code>, мы добавляем ключевое слово <code>extern</code> и указываем ABI для использования непосредственно перед ключевым словом <code>fn</code> для необходимой функции. Нам также нужно добавить аннотацию <code>#[no_mangle]</code>, чтобы сказать компилятору Rust не искажать имя этой функции. <em>Искажение</em> - это когда компилятор меняет имя, которое мы дали функции, на другое имя, которое содержит больше информации для других частей процесса компиляции, но менее читабельно для человека. Компилятор каждого языка программирования искажает имена по-разному, поэтому, чтобы функция Rust могла быть использована другими языками, мы должны отключить искажение имён в компиляторе Rust.</p>
<p>В следующем примере мы делаем функцию <code>call_from_c</code> доступной из кода на C, после того как она будет скомпилирована в разделяемую библиотеку и прилинкована с C:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Такое использование <code>extern</code> не требует <code>unsafe</code>.</p>
</blockquote>
<h3 id="Получение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную"><a class="header" href="#Получение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную">Получение доступа и внесение изменений в изменяемую статическую переменную</a></h3>
<p>В этой книге мы ещё не говорили о <em>глобальных переменных</em>, которые Rust поддерживает, но с которыми могут возникнуть проблемы из-за действующих в Rust правил владения. Если два потока обращаются к одной и той же изменяемой глобальной переменной, это может привести к гонке данных.</p>
<p>Глобальные переменные в Rust называют <em>статическими</em> (static). Листинг 19-9 демонстрирует пример объявления и использования в качестве значения статической переменной, имеющей тип строкового среза:</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-09/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-9: Определение и использование неизменяемой статической переменной</span></p>
<p>Статические переменные похожи на константы, которые мы обсуждали в разделе <a href="ch03-01-variables-and-mutability.html#constants">“Различия между переменными и константами”</a><!-- ignore --> главы 3. Имена статических переменных по общему соглашению пишутся в нотации <code>SCREAMING_SNAKE_CASE</code>, и мы <em>должны</em> указывать тип переменной, которым в данном случае является <code>&amp;'static str</code>. Статические переменные могут хранить только ссылки со временем жизни <code>'static</code>, это означает что компилятор Rust может вывести время жизни и нам не нужно прописывать его явно. Доступ к неизменяемой статической переменной является безопасным.</p>
<p>Тонкое различие между константами и неизменяемыми статическими переменными заключается в том, что значения в статической переменной имеют фиксированный адрес в памяти. При использовании значения всегда будут доступны одни и те же данные. Константы, с другой стороны, могут дублировать свои данные при каждом использовании. Ещё одно отличие заключается в том, что статические переменные могут быть изменяемыми. Обращение к изменяемым статическим переменным и их изменение является <em>небезопасным</em>. В листинге 19-10 показано, как объявить, получить доступ и модифицировать изменяемую статическую переменную с именем <code>COUNTER</code>.</p>
<p><span class="filename">Имя файла: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-10/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-10: Чтение из изменяемой статической переменной или запись в неё небезопасны</span></p>
<p>Как и с обычными переменными, мы определяем изменяемость с помощью ключевого слова <code>mut</code>. Любой код, который читает из или пишет в переменную <code>COUNTER</code> должен находиться в <code>unsafe</code> блоке. Этот код компилируется и печатает <code>COUNTER: 3</code>, как и следовало ожидать, потому что выполняется в одном потоке. Наличие нескольких потоков с доступом к <code>COUNTER</code> приведёт к ситуации гонки данных.</p>
<p>Наличие изменяемых данных, которые доступны глобально, делает трудным реализацию гарантии отсутствия гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительно использовать техники многопоточности и умные указатели, ориентированные на многопоточное исполнение, которые мы обсуждали в главе 16. Таким образом, компилятор сможет проверить, что обращение к данным, доступным из разных потоков, выполняется безопасно.</p>
<h3 id="Реализация-небезопасных-типажей"><a class="header" href="#Реализация-небезопасных-типажей">Реализация небезопасных типажей</a></h3>
<p>Мы можем использовать <code>unsafe</code> для реализации небезопасного трейта. Трейт является небезопасным, если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить. Мы объявляем трейты <code>unsafe</code>, добавляя ключевое слово <code>unsafe</code> перед <code>trait</code> и помечая реализацию трейта как <code>unsafe</code>, как показано в листинге 19-11.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#rustdoc_include ../listings/ch19-advanced-features/listing-19-11/src/main.rs}}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Листинг 19-11: Определение и реализация небезопасного трейта</span></p>
<p>Используя <code>unsafe impl</code>, мы даём обещание поддерживать инварианты, которые компилятор не может проверить.</p>
<p>Для примера вспомним маркерные типажи <code>Sync</code> и <code>Send</code>, которые мы обсуждали в разделе <a data-md-type="raw_html" href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">&quot;Расширяемый параллелизм с помощью типажей <code>Sync</code> и <code>Send</code>&quot;</a><!-- ignore --> главы 16: компилятор реализует эти типажи автоматически, если наши типы полностью состоят из типов <code>Send</code> и <code>Sync</code>. Если мы создадим тип, который содержит тип, не являющийся <code>Send</code> или <code>Sync</code>, такой, как сырой указатель, и мы хотим пометить этот тип как <code>Send</code> или <code>Sync</code>, мы должны использовать <code>unsafe</code> блок. Rust не может проверить, что наш тип поддерживает гарантии того, что он может быть безопасно передан между потоками или доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью <code>unsafe</code>.</p>
<h3 id="Доступ-к-полям-объединений-union"><a class="header" href="#Доступ-к-полям-объединений-union">Доступ к полям объединений (union)</a></h3>
<p>Последнее действие, которое работает только с <code>unsafe</code> - это доступ к полям <em>union</em>. <code>union</code> похож на <code>struct</code>, но в каждом конкретном экземпляре одновременно может использоваться только одно объявленное поле. Объединения в основном используются для взаимодействия с объединениями в коде на языке Си. Доступ к полям объединений небезопасен, поскольку Rust не может гарантированно определить тип данных, которые в данный момент хранятся в экземпляре объединения. Подробнее об объединениях вы можете узнать в <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="Когда-использовать-небезопасный-код"><a class="header" href="#Когда-использовать-небезопасный-код">Когда использовать небезопасный код</a></h3>
<p>Использование <code>unsafe</code> для выполнения одного из пяти действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить корректный <code>unsafe</code> код сложнее, потому что компилятор не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать <code>unsafe</code> код, вы можете делать это, а наличие явной <code>unsafe</code> аннотации облегчает отслеживание источника проблем, если они возникают.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
