<!DOCTYPE HTML>
<html lang="ru-RU" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Рефакторинг для обеспечения модульности и улучшения обработки ошибок - Язык программирования Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Язык программирования Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Введение</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> С чего начать</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Привет, Мир!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Программирование игры в загадки</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Общие концепции программирования</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Переменные и изменяемость</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Типы Данных</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Функции</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Комментарии</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Управляющие конструкции</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Понимание владения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Что такое "владение"?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Ссылки и заимствование</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Тип среза</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Использование структур для объединения связанных данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Определение и создание экземпляров структур</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Пример программы, использующей структуры</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Синтаксис метода</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Перечисления и сопоставление с образцом</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Определение Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Конструкция потока управления match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Лаконичный поток управления с if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Управление растущими проектами с помощью пакетов, крейтов и модулей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Пакеты и крейты</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Определение модулей для управления областью действия и конфиденциальностью</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Пути для ссылки на элемент в дереве модулей</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Введение путей в область видимости с помощью ключевого слова use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Общие коллекции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Хранение списков значений с векторами</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Хранение закодированного текста UTF-8 со строками</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Хранение ключей со связанными значениями в HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Обработка ошибок</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Неустранимые ошибки с panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Устранимые ошибки с Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! или Не panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Общие типы, трейты (характеристики) и время жизни</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Обобщённые типы данных</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Трейты (характеристики): определение разделяемого поведения</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Валидация ссылок посредством сроков жизни</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Написание автоматических тестов</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Как писать тесты</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Управление выполнением тестов</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Организация тестов</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Проект с вводом-выводом: создание программы командной строки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Получение аргументов командной строки</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Чтение файла</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html" class="active"><strong aria-hidden="true">12.3.</strong> Рефакторинг для обеспечения модульности и улучшения обработки ошибок</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Разработка функциональности библиотеки с помощью разработки через тестирование</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Работа с переменными среды</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Запись сообщений об ошибках в stderr вместо stdout</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Функциональные возможности языка: итераторы и замыкания</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Замыкания: анонимные функции, которые захватывают своё окружение</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Обработка последовательности элементов с помощью итераторов</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Улучшение нашего проекта с вводом/выводом</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Сравнение производительности: циклы и итераторы</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Подробнее о Cargo и Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Настройка билдов с помощью профилей выпуска</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Публикация крейта на Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Рабочие области Cargo</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Установка бинарных файлов с Crates.io с помощью cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Расширение возможностей Cargo путём добавления пользовательских команд</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Умные указатели</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Использование Box&lt;T&gt; для указания на данные в куче</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Работа с умными указателями как с обычными ссылками с помощью трейта Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Выполнение кода при очистке с помощью трейта Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, умный указатель с подсчётом ссылок</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; и внутренняя изменяемость</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Ссылочные циклы могут привести к утечке памяти</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Безбоязненный параллелизм</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Использование потоков для параллельного выполнения кода</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Пересылка сообщений для передачи данных между потоками</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Параллелизм с общим состоянием</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Расширяемый параллелизм с помощью трейтов Sync и Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Возможности объектно-ориентированного программирования Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Характеристики объектно-ориентированных языков</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Использование трейт-объектов, допускающих значения разных типов</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Реализация шаблона объектно-ориентированного проектирования</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Шаблоны и сопоставление</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Все места, где могут использоваться шаблоны</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Опровержимость: может ли шаблон не соответствовать</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Синтаксис шаблона</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Расширенные возможности</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Небезопасный код в Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Продвинутые типажи</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Продвинутые типы</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Продвинутые функции и замыкания</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Макросы</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Финальный проект: создание многопоточного веб-сервера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Создание однопоточного веб-сервера</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Превращение нашего однопоточного сервера в многопоточный сервер</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 	Мягкое завершение работы и очистка</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Приложения</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> А — Ключевые слова</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B — Операторы и символы</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C — Выводимые трейты</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D — Полезные инструменты разработки</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E — Редакции</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F — Переводы книги</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G — Как создаётся Rust и «Nightly Rust»</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Язык программирования Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Рефакторинг-для-улучшения-модульности-и-обработки-ошибок"><a class="header" href="#Рефакторинг-для-улучшения-модульности-и-обработки-ошибок">Рефакторинг для улучшения модульности и обработки ошибок</a></h2>
<p>Для улучшения программы мы исправим 4 имеющихся проблемы, связанных со структурой программы и тем как обрабатываются потенциальные ошибки. Во-первых, функция <code>main</code> на данный момент решает две задачи:  анализирует переменные командной строки и читает файлы. По мере роста программы количество отдельных задач, которые обрабатывает функция <code>main</code>, будет увеличиваться. Поскольку эта функция получает больше обязанностей, то становится все труднее понимать её, труднее тестировать и труднее изменять, не сломав одну из её частей. Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу.</p>
<p>Эта проблема также связана со второй проблемой: хотя переменные <code>query</code> и <code>file_path</code> являются переменными конфигурации нашей программы, переменные типа <code>contents</code> используются для выполнения логики программы. Чем длиннее становится <code>main</code>, тем больше переменных нам нужно будет добавить в область видимости; чем больше у нас переменных в области видимости, тем сложнее будет отслеживать назначение каждой переменной. Лучше всего сгруппировать переменные конфигурации в одну структуру, чтобы сделать их назначение понятным.</p>
<p>Третья проблема заключается в том, что мы используем <code>expect</code> для вывода информации об ошибке при проблеме с чтением файла, но сообщение об ошибке просто выведет текст<code>Should have been able to read the file</code>. Чтение файла может не сработать по разным причинам, например: файл не найден или у нас может не быть разрешения на его чтение. Сейчас же, независимо от ситуации, мы напечатаем одно и то же сообщение об ошибке, что не даст пользователю никакой информации!</p>
<p>В-четвёртых, мы используем <code>expect</code> неоднократно для обработки различных ошибок и если пользователь запускает нашу программу без указания достаточного количества аргументов он получит ошибку <code>index out of bounds</code> из Rust, что не совсем понятно описывает проблему. Было бы лучше, если бы весь код обработки ошибок находился в одном месте, чтобы тем, кто будет поддерживать наш код в дальнейшем, нужно было бы вносить изменения только здесь, если потребуется изменить логику обработки ошибок. Наличие всего кода обработки ошибок в одном месте гарантирует, что мы напечатаем сообщения, которые будут иметь смысл для наших конечных пользователей.</p>
<p>Давайте решим эти четыре проблемы путём рефакторинга нашего проекта.</p>
<h3 id="Разделение-ответственности-для-бинарных-проектов"><a class="header" href="#Разделение-ответственности-для-бинарных-проектов"><a name="separation-of-concerns-for-binary-projects"></a>Разделение ответственности для бинарных проектов</a></h3>
<p>Организационная проблема распределения ответственности за выполнение нескольких задач функции <code>main</code>  является общей для многих бинарных проектов. В результате Rust сообщество разработало процесс для использования в качестве руководства по разделению ответственности бинарной программы, когда код в <code>main</code> начинает увеличиваться. Процесс имеет следующие шаги:</p>
<ul>
<li>Разделите код программы на два файла <em>main.rs</em> и <em>lib.rs</em>. Перенесите всю логику работы программы в файл <em>lib.rs</em>.</li>
<li>Пока ваша логика синтаксического анализа командной строки мала, она может оставаться в файле <em>main.rs</em>.</li>
<li>Когда логика синтаксического анализа командной строки становится сложной, извлеките её из <em>main.rs</em> и переместите в <em>lib.rs.</em></li>
</ul>
<p>Функциональные обязанности, которые остаются в функции <code>main</code> после этого процесса должно быть ограничено следующим:</p>
<ul>
<li>Вызов логики разбора командной строки со значениями аргументов</li>
<li>Настройка любой другой конфигурации</li>
<li>Вызов функции <code>run</code> в <em>lib.rs</em></li>
<li>Обработка ошибки, если <code>run</code> возвращает ошибку</li>
</ul>
<p>Этот шаблон о разделении ответственности: <em>main.rs</em> занимается запуском программы, а <em>lib.rs</em> обрабатывает всю логику задачи. Поскольку нельзя проверить функцию <code>main</code> напрямую, то такая структура позволяет проверить всю логику программы путём перемещения её в функции внутри <em>lib.rs</em>. Единственный код, который остаётся в <em>main.rs</em> будет достаточно маленьким, чтобы проверить его корректность прочитав код. Давайте переработаем нашу программу, следуя этому процессу.</p>
<h4 id="Извлечение-парсера-аргументов"><a class="header" href="#Извлечение-парсера-аргументов">Извлечение парсера аргументов</a></h4>
<p>Мы извлечём функциональность для разбора аргументов в функцию, которую вызовет <code>main</code> для подготовки к перемещению логики разбора командной строки в файл <em>src/lib.rs</em>. Листинг 12-5 показывает новый запуск <code>main</code>, который вызывает новую функцию <code>parse_config</code>, которую мы определим сначала в <em>src/main.rs.</em></p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {query}&quot;);
</span><span class="boring">    println!(&quot;In file {file_path}&quot;);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}
</code></pre>
<p><span class="caption">Листинг 12-5: Выделение функции <code>parse_config</code> из <code>main</code></span></p>
<p>Мы все ещё собираем аргументы командной строки в вектор, но вместо присваивания значение аргумента с индексом 1 переменной <code>query</code> и значение аргумента с индексом 2 переменной с именем <code>file_path</code> в функции <code>main</code>, мы передаём весь вектор в функцию <code>parse_config</code>. Функция <code>parse_config</code> затем содержит логику, которая определяет, какой аргумент идёт в какую переменную и передаёт значения обратно в <code>main</code>. Мы все ещё создаём переменные <code>query</code> и <code>file_path</code> в <code>main</code>, но <code>main</code> больше не несёт ответственности за определение соответствия аргумента командной строки и соответствующей переменной.</p>
<p>Эта доработка может показаться излишней для нашей маленькой программы, но мы проводим рефакторинг небольшими, постепенными шагами. После внесения этого изменения снова запустите программу и убедитесь, что анализ аргументов все ещё работает. Также хорошо часто проверять прогресс, чтобы помочь определить причину проблем, когда они возникают.</p>
<h4 id="Группировка-конфигурационных-переменных"><a class="header" href="#Группировка-конфигурационных-переменных">Группировка конфигурационных переменных</a></h4>
<p>Мы можем сделать ещё один маленький шаг для улучшения функции <code>parse_config</code>. На данный момент мы возвращаем кортеж, но затем мы немедленно разделяем его снова на отдельные части. Это признак того, что, возможно,  пока у нас нет правильной абстракции.</p>
<p>Ещё один индикатор, который показывает, что есть место для улучшения, это часть <code>config</code> из <code>parse_config</code>, что подразумевает, что два значения, которые мы возвращаем, связаны друг с другом и оба являются частью одного конфигурационного значения. В настоящее время мы не отражаем этого смысла в структуре данных, кроме группировки двух значений в кортеж; мы могли бы поместить оба значения в одну структуру и дать каждому из полей структуры понятное имя. Это облегчит будущую поддержку этого кода, чтобы понять, как различные значения относятся друг к другу и какое их назначение.</p>
<p>В листинге 12-6 показаны улучшения функции <code>parse_config</code> .</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}
</code></pre>
<p><span class="caption">Листинг 12-6: Рефакторинг функции <code>parse_config</code>, чтобы возвращать экземпляр структуры <code>Config</code></span></p>
<p>Мы добавили структуру с именем <code>Config</code> объявленную с полями назваными как <code>query</code> и <code>file_path</code>. Сигнатура <code>parse_config</code> теперь указывает, что она возвращает значение <code>Config</code>. В теле <code>parse_config</code>, где мы возвращали срезы строк, которые ссылаются на значения <code>String</code> в <code>args</code>, теперь мы определяем <code>Config</code> как содержащие собственные <code>String</code> значения. Переменная <code>args</code> в <code>main</code> является владельцем значений аргумента и позволяют функции <code>parse_config</code> только одалживать их, что означает, что мы бы нарушили правила заимствования Rust, если бы <code>Config</code> попытался бы взять во владение значения в <code>args</code> .</p>
<p>Мы можем управлять данными <code>String</code> разным количеством способов, но самый простой, хотя и отчасти неэффективный это вызвать метод <code>clone</code> у значений. Он сделает полную копию данных для экземпляра <code>Config</code> для владения, что занимает больше времени и памяти, чем сохранение ссылки на строку данных. Однако клонирование данных также делает наш код очень простым, потому что нам не нужно управлять временем жизни ссылок; в этом обстоятельстве, отказ от небольшой производительности, чтобы получить простоту, стоит небольших компромисса.</p>
<blockquote>
<p><h>Компромиссы при использовании метода <code>clone</code></h>Существует тенденция в среде программистов Rust избегать использования <code>clone</code>, т.к. это понижает эффективность работы кода. В <a href="ch13-00-functional-features.html">Главе 13</a><!-- ignore -->, вы изучите более эффективные методы, которые могут подойти в подобной ситуации. Но сейчас можно копировать несколько строк, чтобы продолжить работу, потому что вы сделаете эти копии только один раз, а ваше имя файла и строка запроса будут очень маленькими. Лучше иметь работающую программу, которая немного неэффективна, чем пытаться заранее оптимизировать код при первом написании. По мере приобретения опыта работы с Rust вам будет проще начать с наиболее эффективного решения, но сейчас вполне приемлемо вызвать <code>clone</code>.</p>
</blockquote>
<p>Мы обновили код в <code>main</code> поэтому он помещает экземпляр <code>Config</code> возвращённый из <code>parse_config</code> в переменную с именем <code>config</code>, и мы обновили код, в котором ранее использовались отдельные переменные <code>query</code> и <code>file_path</code>, так что теперь он использует вместо этого поля в структуре <code>Config</code>.</p>
<p>Теперь наш код более чётко передаёт то, что <code>query</code> и <code>file_path</code> связаны и что цель из использования состоит в том, чтобы настроить, как программа будет работать. Любой код, который использует эти значения знает, что может найти их в именованных полях экземпляра <code>config</code> по их назначению.</p>
<h4 id="Создание-конструктора-для-структуры-config"><a class="header" href="#Создание-конструктора-для-структуры-config">Создание конструктора для структуры <code>Config</code></a></h4>
<p>Пока что мы извлекли логику, отвечающую за синтаксический анализ аргументов командной строки из <code>main</code> и поместили его в функцию <code>parse_config</code>. Это помогло нам увидеть, что значения <code>query</code> и <code>file_path</code> были связаны и что их отношения должны быть отражены в нашем коде. Затем мы добавили структуру <code>Config</code> в качестве названия связанных общей целью <code>query</code> и <code>file_path</code> и чтобы иметь возможность вернуть именованные значения как имена полей структуры из функции <code>parse_config</code>.</p>
<p>Итак, теперь целью функции <code>parse_config</code> является создание экземпляра <code>Config</code>, мы можем изменить <code>parse_config</code> из простой функции на функцию названную <code>new</code>, которая связана со структурой <code>Config</code>. Выполняя это изменение мы сделаем код более идиоматичным. Можно создавать экземпляры типов в стандартной библиотеке, такие как <code>String</code> с помощью вызова <code>String::new</code>. Точно так же изменив название <code>parse_config</code> на название функции <code>new</code>, связанную с <code>Config</code>, мы будем уметь создавать экземпляры <code>Config</code>, вызывая <code>Config::new</code>. Листинг 12-7 показывает изменения, которые мы должны сделать.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}
</code></pre>
<p><span class="caption">Листинг 12-7: Переименование <code>parse_config</code> в <code>Config::new</code></span></p>
<p>Мы обновили <code>main</code> где вызывали <code>parse_config</code>, чтобы вместо этого вызывалась <code>Config::new</code>. Мы изменили имя <code>parse_config</code> на <code>new</code> и перенесли его внутрь блока <code>impl</code>, который связывает функцию <code>new</code> с <code>Config</code>. Попробуйте снова скомпилировать код, чтобы убедиться, что он работает.</p>
<h3 id="Исправление-ошибок-обработки"><a class="header" href="#Исправление-ошибок-обработки">Исправление ошибок обработки</a></h3>
<p>Теперь мы поработаем над исправлением обработки ошибок. Напомним, что попытки получить доступ к значениям в векторе <code>args</code> с индексом 1 или индексом 2 приведут к панике, если вектор содержит менее трёх элементов. Попробуйте запустить программу без каких-либо аргументов; это будет выглядеть так:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Строка <code>index out of bounds: the len is 1 but the index is 1</code> является сообщением об ошибке предназначенной для программистов. Она не поможет нашим конечным пользователям понять, что случилось и что они должны сделать вместо этого. Давайте исправим это сейчас.</p>
<h4 id="Улучшение-сообщения-об-ошибке"><a class="header" href="#Улучшение-сообщения-об-ошибке">Улучшение сообщения об ошибке</a></h4>
<p>В листинге 12-8 мы добавляем проверку в функцию <code>new</code>, которая будет проверять, что срез достаточно длинный, перед попыткой доступа по индексам 1 и 2. Если срез не достаточно длинный, программа паникует и отображает улучшенное сообщение об ошибке.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Листинг 12-8: Добавление проверки количества аргументов</span></p>
<p>Этот код похож на <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">функцию <code>Guess::new</code> написанную в листинге 9-13</a>, где мы вызывали <code>panic!</code>, когда <code>value</code> аргумента вышло за пределы допустимых значений. Здесь вместо проверки на диапазон значений, мы проверяем, что длина <code>args</code> не менее 3 и остальная часть функции может работать при условии, что это условие было выполнено. Если в <code>args</code> меньше трёх элементов, это условие будет истинным и мы вызываем макрос <code>panic!</code> для немедленного завершения программы.</p>
<p>Имея нескольких лишних строк кода в <code>new</code>, давайте запустим программу снова без аргументов, чтобы увидеть, как выглядит ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Этот вывод лучше: у нас теперь есть разумное сообщение об ошибке. Тем не менее, мы также имеем постороннюю информацию, которую мы не хотим предоставлять нашим пользователям. Возможно, использованная техника, которую мы использовали в листинге 9-13, не является лучшей для использования: вызов <code>panic!</code> больше подходит для программирования проблемы, чем решения проблемы, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">как обсуждалось в главе 9</a><!-- ignore -->. Вместо этого мы можем использовать другую технику, о которой вы узнали в главе 9 [возвращая <code>Result</code>]<!-- ignore -->, которая указывает либо на успех, либо на ошибку.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="Возвращение-result-вместо-вызова-panic"><a class="header" href="#Возвращение-result-вместо-вызова-panic">Возвращение <code>Result</code> вместо вызова <code>panic!</code></a></h4>
<p>Мы можем вернуть значение <code>Result</code>, которое будет содержать экземпляр <code>Config</code> в успешном случае и опишет проблему в случае ошибки. Мы так же изменим функцию <code>new</code> на <code>build</code> потому что многие программисты ожидают что <code>new</code> никогда не завершится неудачей. Когда <code>Config::build</code> взаимодействует с <code>main</code>, мы можем использовать тип <code>Result</code> как сигнал возникновения проблемы. Затем мы можем изменить <code>main</code>, чтобы преобразовать вариант <code>Err</code> в более практичную ошибку для наших пользователей без окружающего текста вроде <code>thread 'main'</code> и <code>RUST_BACKTRACE</code>, что происходит при вызове <code>panic!</code>.</p>
<p>Листинг 12-9 показывает изменения, которые нужно внести в возвращаемое значения функции <code>Config::build</code>, и в тело функции, необходимые для возврата типа <code>Result</code>. Заметьте, что этот код не скомпилируется, пока мы не обновим <code>main</code>, что мы и сделаем в следующем листинге.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}
</code></pre>
<p><span class="caption">Листинг 12-9. Возвращение типа <code>Result</code> из <code>Config::build</code></span></p>
<p>Наша функция <code>build</code> теперь возвращает <code>Result</code> с экземпляром <code>Config</code> в случае успеха и <code>&amp;'static str</code> в случае ошибки. Значения ошибок всегда будут строковыми литералами, которые имеют время жизни <code>'static</code>.</p>
<p>Мы внесли два изменения в тело функции <code>build</code>: вместо вызова <code>panic!</code>, когда пользователь не передаёт достаточно аргументов, мы теперь возвращаем <code>Err</code> значение и мы завернули возвращаемое значение <code>Config</code> в <code>Ok</code> . Эти изменения заставят функцию соответствовать своей новой сигнатуре типа.</p>
<p>Возвращение значения <code>Err</code> из <code>Config::build</code> позволяет функции <code>main</code> обработать значение <code>Result</code> возвращённое из функции <code>build</code> и выйти из процесса более чисто в случае ошибки.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="Вызов-configbuild-и-обработка-ошибок"><a class="header" href="#Вызов-configbuild-и-обработка-ошибок">Вызов <code>Config::build</code> и обработка ошибок</a></h4>
<p>Чтобы обработать ошибку и вывести более дружественное сообщение об ошибке, нам нужно обновить код <code>main</code> для обработки <code>Result</code>, возвращаемого из <code>Config::build</code> как показано в листинге 12-10. Мы также возьмём на себя ответственность за выход из программы командной строки с ненулевым кодом ошибки <code>panic!</code> и реализуем это вручную. Не нулевой статус выхода - это соглашение, которое сигнализирует процессу, который вызывает нашу программу, что программа завершилась с ошибкой.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;Should have been able to read the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Листинг 12-10. Выход с кодом ошибки если создание новой <code>Config</code> терпит неудачу</span></p>
<p>В этом листинге мы использовали метод, который мы ещё не рассматривали детально: <code>unwrap_or_else</code>, который в стандартной библиотеке определён как <code>Result&lt;T, E&gt;</code>. Использование <code>unwrap_or_else</code> позволяет нам определить некоторые пользовательские ошибки обработки, не содержащие <code>panic!</code>. Если <code>Result</code> является значением <code>Ok</code>, поведение этого метода аналогично <code>unwrap</code>: возвращает внутреннее значение из обёртки <code>Ok</code>. Однако, если значение является значением <code>Err</code>, то этот метод вызывает код <em>замыкания</em>, которое является анонимной функцией, определённой заранее и передаваемую в качестве аргумента в <code>unwrap_or_else</code>. Мы рассмотрим замыкания более подробно в <a href="ch13-00-functional-features.html">главе 13</a>. В данный момент, вам просто нужно знать, что <code>unwrap_or_else</code> передаст внутреннее значение <code>Err</code>, которое в этом случае является статической строкой <code>not enough arguments</code>, которое мы добавили в листинге 12-9, в наше замыкание как аргумент <code>err</code> указанное между вертикальными линиями. Код в замыкании может затем использовать значение <code>err</code> при выполнении.</p>
<p>Мы добавили новую строку <code>use</code>, чтобы подключить <code>process</code> из стандартной библиотеки в область видимости. Код в замыкании, который будет запущен в случае ошибки содержит только две строчки: мы печатаем значение <code>err</code> и затем вызываем <code>process::exit</code>. Функция <code>process::exit</code> немедленно остановит программу и вернёт номер, который был передан в качестве кода состояния выхода. Это похоже на обработку с помощью макроса <code>panic!</code>, которую мы использовали в листинге 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Замечательно! Этот вывод намного дружелюбнее для наших пользователей.</p>
<h3 id="Извлечение-логики-из-main"><a class="header" href="#Извлечение-логики-из-main">Извлечение логики из <code>main</code></a></h3>
<p>Теперь, когда мы закончили рефакторинг разбора конфигурации, давайте обратимся к логике программы. Как мы указали в разделе <a href="#separation-of-concerns-for-binary-projects">«Разделение ответственности в бинарных проектах»</a><!-- ignore -->, мы извлечём функцию с именем <code>run</code>, которая будет содержать всю логику, присутствующую в настоящее время в функции <code>main</code> и которая не связана с настройкой конфигурации или обработкой ошибок. Когда мы закончим, то <code>main</code> будет краткой, легко проверяемой и мы сможем написать тесты для всей остальной логики.</p>
<p>Код 12-11 демонстрирует извлечённую логику в функцию <code>run</code>. Мы делаем маленькое, инкрементальное приближение к извлечению функции. Код всё ещё сосредоточен в файле <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;Should have been able to read the file&quot;);

    println!(&quot;With text:\n{contents}&quot;);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Листинг 12-11. Извлечение функции <code>run</code>, содержащей остальную логику программы</span></p>
<p>Функция <code>run</code> теперь содержит всю оставшуюся логику из <code>main</code>, начиная от чтения файла. Функция <code>run</code> принимает экземпляр <code>Config</code> как аргумент.</p>
<h4 id="Возврат-ошибок-из-функции-run"><a class="header" href="#Возврат-ошибок-из-функции-run">Возврат ошибок из функции <code>run</code></a></h4>
<p>Оставшаяся логика программы выделена в функцию <code>run</code>, где мы можем улучшить обработку ошибок как мы уже делали с <code>Config::build</code> в листинге 12-9. Вместо того, чтобы позволить программе паниковать с помощью вызова <code>expect</code>, функция <code>run</code> вернёт <code>Result&lt;T, E&gt;</code>, если что-то пойдёт не так. Это позволит далее консолидировать логику обработки ошибок в <code>main</code> удобным способом. Листинг 12-12 показывает изменения, которые мы должны внести в сигнатуру и тело <code>run</code>.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;With text:\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Листинг 12-12. Изменение функции <code>run</code> для возврата <code>Result</code></span></p>
<p>Здесь мы сделали три значительных изменения. Во-первых, мы изменили тип возвращаемого значения функции <code>run</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> . Эта функция ранее возвращала тип <code>()</code> и мы сохраняли его как значение, возвращаемое в случае <code>Ok</code>.</p>
<p>Для типа ошибки мы использовали <em>объект типаж</em> <code>Box&lt;dyn Error&gt;</code> (и вверху мы подключили тип <code>std::error::Error</code> в область видимости с помощью инструкции <code>use</code>). Мы рассмотрим типажи объектов в <a href="ch17-00-oop.html">главе 17</a><!-- ignore -->. Сейчас просто знайте, что <code>Box&lt;dyn Error&gt;</code> означает, что функция будет возвращать тип реализующий типаж <code>Error</code>, но не нужно указывать, какой именно будет тип возвращаемого значения. Это даёт возможность возвращать значения ошибок, которые могут быть разных типов в разных случаях. Ключевое слово <code>dyn</code> сокращение для слова «динамический».</p>
<p>Во-вторых, мы убрали вызов <code>expect</code> в пользу использования оператора <code>?</code>, как мы обсудили в <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">главе 9</a><!-- ignore -->. Скорее, чем вызывать <code>panic!</code> в случае ошибки, оператор <code>?</code> вернёт значение ошибки из текущей функции для вызывающего, чтобы он её обработал.</p>
<p>В-третьих, функция <code>run</code> теперь возвращает значение <code>Ok</code> в случае успеха. В сигнатуре функции <code>run</code> успешный тип объявлен как <code>()</code>, который означает, что нам нужно обернуть значение единичного типа в значение <code>Ok</code>. Данный синтаксис <code>Ok(())</code> поначалу может показаться немного странным, но использование <code>()</code> выглядит как идиоматический способ указать, что мы вызываем <code>run</code> для его побочных эффектов; он не возвращает значение, которое нам нужно.</p>
<p>Когда вы запустите этот код, он скомпилируется, но отобразит предупреждение:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust говорит, что наш код проигнорировал <code>Result</code> значение и значение <code>Result</code> может указывать на то, что произошла ошибка. Но мы не проверяем, была ли ошибка и компилятор напоминает нам, что мы, вероятно, хотели здесь выполнить некоторый код обработки ошибок! Давайте исправим эту проблему сейчас.</p>
<h4 id="Обработка-ошибок-возвращённых-из-run-в-main"><a class="header" href="#Обработка-ошибок-возвращённых-из-run-в-main">Обработка ошибок, возвращённых из <code>run</code> в <code>main</code></a></h4>
<p>Мы будем проверять и обрабатывать ошибки используя методику, аналогичную той, которую мы использовали для <code>Config::build</code> в листинге 12-10, но с небольшой разницей:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {e}&quot;);
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Мы используем <code>if let</code> вместо <code>unwrap_or_else</code> чтобы проверить, возвращает ли <code>run</code> значение <code>Err</code> и вызывается <code>process::exit(1)</code>, если это так. Функция <code>run</code> не возвращает значение, которое мы хотим развернуть методом <code>unwrap</code>, таким же образом как <code>Config::build</code> возвращает экземпляр <code>Config</code>. Так как <code>run</code> возвращает <code>()</code> в случае успеха и мы заботимся только об обнаружении ошибки, то нам не нужно вызывать <code>unwrap_or_else</code>, чтобы вернуть развёрнутое значение, потому что оно будет только <code>()</code>.</p>
<p>Тело функций <code>if let</code> и <code>unwrap_or_else</code> одинаковы в обоих случаях: мы печатаем ошибку и выходим.</p>
<h3 id="Разделение-кода-на-библиотечный-крейт"><a class="header" href="#Разделение-кода-на-библиотечный-крейт">Разделение кода на библиотечный крейт</a></h3>
<p>Наш проект <code>minigrep</code> пока выглядит хорошо! Теперь мы разделим файл <em>src/main.rs</em> и поместим некоторый код в файл <em>src/lib.rs</em>. Таким образом мы сможем его тестировать и чтобы в файле <em>src/main.rs</em> было меньшее количество функциональных обязанностей.</p>
<p>Давайте перенесём весь код не относящийся к функции <code>main</code> из файла <em>src/main.rs</em> в новый файл <em>src/lib.rs</em>:</p>
<ul>
<li>Определение функции <code>run</code></li>
<li>Соответствующие инструкции <code>use</code></li>
<li>Определение структуры <code>Config</code></li>
<li>Определение функции <code>Config::build</code></li>
</ul>
<p>Содержимое <em>src/lib.rs</em> должно иметь сигнатуры, показанные в листинге 12-13 (мы опустили тела функций для краткости). Обратите внимание, что код не будет компилироваться пока мы не изменим <em>src/main.rs</em> в листинге 12-14.</p>
<p><span class="filename">Файл: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Листинг 12-13. Перемещение <code>Config</code> и <code>run</code> в <em>src/lib.rs</em></span></p>
<p>Мы добавили спецификатор доступа <code>pub</code> к структуре <code>Config</code>, а также её полям, к методу <code>build</code> и функции <code>run</code>. Теперь у нас есть библиотечный крейт, который содержит публичный API, который мы можем протестировать!</p>
<p>Теперь нам нужно подключить код, который мы переместили в <em>src/lib.rs,</em> в область видимости бинарного крейта внутри <em>src/main.rs</em>, как показано в листинге 12-14.</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {e}&quot;);
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">Листинг 12-14. Использование крейта библиотеки <code>minigrep</code> внутри <em>src/main.rs</em></span></p>
<p>Мы добавляем <code>use minigrep::Config</code> для подключения типа <code>Config</code> из крейта библиотеки в область видимости бинарного крейта и добавляем к имени функции <code>run</code> префикс нашего крейта. Теперь все функции должны быть подключены и должны работать. Запустите программу с <code>cargo run</code> и убедитесь, что все работает правильно.</p>
<p>Уф! Было много работы, но мы настроены на будущий успех. Теперь проще обрабатывать ошибки и мы сделали код более модульным. С этого момента почти вся наша работа будет выполняться внутри <em>src/lib.rs</em>.</p>
<p>Давайте воспользуемся этой новой модульностью, сделав что-то, что было бы трудно со старым кодом, но легко с новым кодом: мы напишем несколько тестов!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
